<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Post</title>
  <link rel="stylesheet" href="style.css" />
  <!-- Add Google Fonts for Cursive Options -->
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script&family=Great+Vibes&family=Pacifico&family=Satisfy&family=Allura&family=Tangerine&family=Pinyon+Script&family=Alex+Brush&display=swap" rel="stylesheet">
  <style>
    .content {
      display: flex;
      gap: 2rem;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    main {
      flex: 1;
      max-width: 800px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    article {
      width: 100%;
      text-align: center;
    }

    article h2 {
      margin-bottom: 20px;
    }

    article img {
      max-width: 100%;
      height: auto;
      margin: 20px auto;
      display: block;
      border-radius: 8px;
    }

    article p {
      text-align: left;
      line-height: 1.6;
      margin: 20px 0;
    }

    section {
      width: 100%;
      max-width: 600px;
      margin: 0 auto;
    }

    section h3, section h2 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 1.5em;
      position: relative;
    }
    
    section h3::after, section h2::after {
      content: "";
      display: block;
      width: 30%;
      height: 1px;
      background-color: #000;
      margin: 10px auto;
    }

    /* New comment form styling */
    #commentForm {
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 500px;
      margin: 0 auto;
      background-color: #f9f9f9;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      box-sizing: border-box;
    }

    #commentForm label {
      font-size: 0.85em;
      font-weight: bold;
      margin-bottom: 5px;
      color: #222;
    }

    #commentForm textarea,
    #commentForm input {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-bottom: 15px;
      font-family: inherit;
      font-size: 0.95em;
      transition: border-color 0.3s;
      box-sizing: border-box;
    }
    
    #commentForm textarea:focus,
    #commentForm input:focus {
      border-color: #222;
      outline: none;
    }

    #commentForm textarea {
      min-height: 120px;
      max-height: 200px;
      resize: vertical;
      overflow-y: auto;
      line-height: 1.4;
    }

    #commentForm button {
      align-self: flex-end;
      padding: 8px 16px;
      background: transparent;
      border: 2px solid #222;
      color: #222;
      font-size: 14px;
      font-weight: bold;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    #commentForm button:hover {
      background: #222;
      color: white;
    }
    
    /* Form avatar styles */
    .form-row {
      display: flex;
      gap: 20px;
      margin-bottom: 15px;
    }
    
    .form-avatar-container {
      flex-shrink: 0;
      width: 100px;
    }
    
    .form-fields {
      flex: 1;
    }
    
    .avatar-preview {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      margin-bottom: 10px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #f0f0f0;
      border: 1px solid #ddd;
    }
    
    #avatarPreview {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      color: #666;
      overflow: hidden;
    }
    
    #avatarPreview img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .avatar-upload {
      margin-bottom: 15px;
    }
    
    .avatar-upload label {
      display: block;
      margin-bottom: 5px;
    }
    
    .avatar-upload input[type="file"] {
      font-size: 12px;
      width: 100%;
    }
    
    .avatar-upload small {
      display: block;
      font-size: 12px;
      color: #777;
      margin-top: 3px;
    }
    
    /* Responsive adjustments */
    @media (max-width: 600px) {
      .form-row {
        flex-direction: column;
      }
      
      .form-avatar-container {
        width: 100%;
        display: flex;
        gap: 20px;
        align-items: center;
      }
      
      .avatar-preview {
        margin-bottom: 0;
      }
    }
    
    /* Comment display styles */
    #commentsContainer {
      margin: 30px 0;
    }
    
    .comment {
      padding: 15px;
      border-bottom: 1px solid #eee;
      margin-bottom: 15px;
      transition: background-color 0.2s;
    }
    
    .comment:hover {
      background-color: #f9f9f9;
    }
    
    .comment:last-child {
      border-bottom: none;
    }
    
    .comment-header {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .comment-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      margin-right: 12px;
      background-color: #f0f0f0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: #555;
      flex-shrink: 0;
      overflow: hidden;
    }
    
    .comment-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .comment-info {
      flex: 1;
    }
    
    .comment-author {
      font-weight: bold;
      color: #333;
      margin-bottom: 3px;
      font-size: 0.95em;
    }
    
    .comment-date {
      color: #888;
      font-size: 0.85em;
    }
    
    .comment-content {
      margin: 0 0 15px 52px;
      line-height: 1.5;
      font-size: 0.95em;
    }
    
    .comment-actions {
      margin-left: 52px;
      display: flex;
      gap: 15px;
    }
    
    .comment-action {
      font-size: 0.85em;
      color: #666;
      cursor: pointer;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
    }
    
    .comment-action:hover {
      color: #222;
      text-decoration: underline;
    }
    
    /* Nested replies */
    .reply-list {
      margin: 15px 0 0 52px;
      padding-left: 15px;
      border-left: 2px solid #eee;
    }
    
    .reply-form {
      margin: 15px 0 15px 52px;
      display: none;
    }
    
    .reply-form.visible {
      display: block;
    }
    
    .reply-form textarea {
      width: 100%;
      min-height: 80px;
      resize: vertical;
      padding: 10px;
      margin-bottom: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: inherit;
      font-size: 0.95em;
    }
    
    .reply-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    
    .reply-actions button {
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 0.9em;
      cursor: pointer;
    }
    
    .reply-cancel {
      background: none;
      border: 1px solid #ddd;
    }
    
    .reply-submit {
      background: #333;
      color: white;
      border: none;
    }
    
    .reply-cancel:hover {
      background: #f5f5f5;
    }
    
    .reply-submit:hover {
      background: #444;
    }

    .about-me {
      width: 300px;
      flex-shrink: 0;
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .profile-pic {
      width: 150px;
      height: 150px;
      border-radius: 50%;
      margin-bottom: 20px;
      display: block;
      margin-left: auto;
      margin-right: auto;
    }

    .search-container {
      margin: 20px 0;
    }

    .search-container input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .recent-posts {
      margin: 20px 0;
    }

    .recent-post-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 0;
      text-decoration: none;
      color: inherit;
    }

    .recent-post-item img {
      width: 60px;
      height: 60px;
      object-fit: cover;
      border-radius: 4px;
    }

    .post-title {
      font-size: 0.9em;
      line-height: 1.4;
    }

    .social-links {
      margin-top: 20px;
    }

    .social-icons {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .social-icon {
      padding: 8px 15px;
      background: #f0f0f0;
      border-radius: 4px;
      text-decoration: none;
      color: #333;
      font-size: 0.9em;
    }

    @media (max-width: 768px) {
      .content {
        flex-direction: column;
      }
      
      .about-me {
        width: 100%;
        margin-top: 20px;
      }
    }

    .comments-section {
      margin-top: 40px;
      padding: 20px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .comments-section h2 {
      margin-bottom: 20px;
      color: #333;
      font-size: 1.5em;
    }

    .comment {
      padding: 15px;
      border-bottom: 1px solid #eee;
      margin-bottom: 15px;
    }

    .comment:last-child {
      border-bottom: none;
    }

    .comment-header {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }

    .comment-author {
      font-weight: bold;
      color: #333;
      margin-right: 10px;
    }

    .comment-date {
      color: #666;
      font-size: 0.9em;
    }

    .comment-content {
      color: #444;
      line-height: 1.5;
      margin: 0;
    }

    .comment-form {
      margin-top: 30px;
    }

    .comment-form h3 {
      margin-bottom: 15px;
      color: #333;
      font-size: 1.2em;
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-group label {
      display: block;
      margin-bottom: 5px;
      color: #333;
      font-weight: 500;
    }

    .form-group input,
    .form-group textarea {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 0.95em;
    }

    .form-group textarea {
      min-height: 100px;
      resize: vertical;
    }

    .submit-btn {
      background: #333;
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.95em;
      transition: background 0.3s;
    }

    .submit-btn:hover {
      background: #444;
    }

    .no-comments {
      color: #666;
      font-style: italic;
      margin: 20px 0;
    }

    /* Add these styles to ensure proper font display */
    #postHeading {
      font-size: 2.5em;
      margin-bottom: 1em;
      line-height: 1.3;
      overflow-wrap: break-word;
      word-wrap: break-word;
      word-break: break-word;
      hyphens: auto;
    }

    /* Add specific font styles */
    #postHeading[style*="font-family: 'Dancing Script'"],
    #postHeading[style*="font-family: Dancing Script"] {
      font-family: 'Dancing Script', cursive !important;
    }
    
    #postHeading[style*="font-family: 'Great Vibes'"],
    #postHeading[style*="font-family: Great Vibes"] {
      font-family: 'Great Vibes', cursive !important;
    }
    
    #postHeading[style*="font-family: 'Pacifico'"],
    #postHeading[style*="font-family: Pacifico"] {
      font-family: 'Pacifico', cursive !important;
    }
    
    #postHeading[style*="font-family: 'Satisfy'"],
    #postHeading[style*="font-family: Satisfy"] {
      font-family: 'Satisfy', cursive !important;
    }
    
    #postHeading[style*="font-family: 'Allura'"],
    #postHeading[style*="font-family: Allura"] {
      font-family: 'Allura', cursive !important;
    }
    
    #postHeading[style*="font-family: 'Brush Script MT'"],
    #postHeading[style*="font-family: Brush Script MT"] {
      font-family: 'Brush Script MT', cursive !important;
    }
    
    #postHeading[style*="font-family: 'Tangerine'"],
    #postHeading[style*="font-family: Tangerine"] {
      font-family: 'Tangerine', cursive !important;
    }
    
    #postHeading[style*="font-family: 'Alex Brush'"],
    #postHeading[style*="font-family: Alex Brush"] {
      font-family: 'Alex Brush', cursive !important;
    }
    
    #postHeading[style*="font-family: 'Pinyon Script'"],
    #postHeading[style*="font-family: Pinyon Script"] {
      font-family: 'Pinyon Script', cursive !important;
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <div class="logo">
        <a href="index.html">
          <img src="nbvlogo.png" alt="Ny's Beauty Vault Logo" style="max-height: 100px; width: auto;">
        </a>
      </div>
      <nav id="mainNav">
        <a href="index.html">Home</a>
        <a href="about.html">About</a>
        <a href="contact.html">Contact</a>
        <!-- Admin-only link (initially hidden) -->
        <a id="adminDashboard" href="admin-dashboard.html" style="display:none;">Admin Dashboard</a>
        <!-- Public links -->
        <a id="login-link" href="login.html">Login</a>
        <button id="logout-btn" style="display:none;">Logout</button>
      </nav>
    </div>
  </header>

  <div class="content">
    <main>
      <article>
        <h2 id="postHeading">Post Content</h2>
        <hr style="width: 30%; margin: 10px auto; border-top: 1px solid #000; border-bottom: none;">
        <p id="postDate" class="post-date" style="color: #666; font-size: 0.9em; margin-bottom: 20px; text-align: center; font-style: italic;"></p>
        <img id="postImage" style="max-width: 100%; display: none;" alt="Post Image" />
        <p id="postContent">Fetching post...</p>
      </article>

      <!-- Comments Section -->
      <section>
        <h3>Comments</h3>
        <!-- Existing comments will be appended here -->
        <div id="commentsContainer"></div>

        <h2>Leave a Reply</h2>
        <p class="comment-description">Your email address will not be published. Required fields are marked *</p>

        <form id="commentForm">
          <div class="form-row">
            <div class="form-avatar-container">
              <div class="avatar-preview">
                <div id="avatarPreview">
                  <span id="avatarInitial"></span>
                </div>
              </div>
              <div class="avatar-upload">
                <label for="avatarUpload">Profile Picture</label>
                <input type="file" id="avatarUpload" accept="image/*" />
                <small>Optional. Max 2MB.</small>
              </div>
            </div>
            <div class="form-fields">
              <label for="name">Name*</label>
              <input id="name" name="name" type="text" placeholder="Your name" required />
              
              <label for="email">Email*</label>
              <input id="email" name="email" type="email" placeholder="Your email" required />
            </div>
          </div>
          
          <label for="commentText">Comment*</label>
          <textarea id="commentText" name="commentText" placeholder="Share your thoughts..." required></textarea>
          
          <button type="submit">Post Comment</button>
        </form>
      </section>
    </main>

    <!-- About Me Sidebar -->
    <aside class="about-me">
      <img src="nyredhair.jpg" alt="Ny Red Hair" class="profile-pic">

      <p>
        Hello and welcome to my Makeup and Beauty Blog! I'm Ny, an aspiring makeup artist who's absolutely head-over-heels for all things beauty.
      </p>
      <p>
        Dive into honest product rundowns, foolproof tutorials, and the latest beauty buzzâ€”like a monthly magazine come to life, but with my personal spin (and the occasional cameo from my family). Enjoy!
      </p>

      <!-- Search Bar -->
      <div class="search-container">
        <input type="text" placeholder="Search posts..." id="searchInput">
      </div>

      <!-- Recent Posts -->
      <div class="recent-posts">
        <h3 style="font-size: 1.1em; margin: 20px 0 10px;">Recent Posts</h3>
        <div id="recentPostsList"></div>
      </div>

      <!-- Social Media Links -->
      <div class="social-links">
        <h3 style="font-size: 1.1em; margin: 20px 0 10px;">Follow Me</h3>
        <div class="social-icons">
          <a href="#" class="social-icon">Instagram</a>
          <a href="#" class="social-icon">Facebook</a>
          <a href="#" class="social-icon">Twitter</a>
          <a href="#" class="social-icon">YouTube</a>
        </div>
      </div>
    </aside>
  </div>

  <footer>
    <p>&copy; 2025 Makeup by NY</p>
  </footer>

  <!-- Main script block -->
  <script type="module">
    import {
      doc,
      getDoc,
      collection,
      addDoc,
      getDocs,
      query,
      orderBy,
      serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js";
    import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-auth.js";
    import { db, auth } from "./firebase-config.js";

    // Define admin user ID
    const adminUID = "yuoaYY14sINHaqtNK5EAz4nl8cc2";

    // Check authentication state
    onAuthStateChanged(auth, async (user) => {
      if (user) {
        // User is signed in
        document.getElementById("login-link").style.display = "none";
        document.getElementById("logout-btn").style.display = "inline";
        
        // Check if user is admin
        if (user.uid === adminUID) {
          document.getElementById("adminDashboard").style.display = "inline";
        } else {
          document.getElementById("adminDashboard").style.display = "none";
        }
        
        // Auto-fill comment form with user data
        try {
          const userRef = doc(db, "users", user.uid);
          const userDoc = await getDoc(userRef);
          
          if (userDoc.exists()) {
            const userData = userDoc.data();
            const nameField = document.getElementById("name");
            const emailField = document.getElementById("email");
            
            // Set values from Firestore data
            if (nameField) {
              // Use username first, then full name, then first name
              if (userData.username) {
                nameField.value = userData.username;
              } else if (userData.firstName && userData.lastName) {
                nameField.value = `${userData.firstName} ${userData.lastName}`.trim();
              } else if (userData.firstName) {
                nameField.value = userData.firstName;
              }
              
              if (nameField.value) {
                nameField.readOnly = true;
                
                // Update avatar initial
                const avatarInitial = document.getElementById("avatarInitial");
                if (avatarInitial) {
                  avatarInitial.textContent = nameField.value.charAt(0).toUpperCase();
                }
              }
            }
            
            if (emailField) {
              // Use Firestore email first, then Auth email
              if (userData.email) {
                emailField.value = userData.email;
              } else if (user.email) {
                emailField.value = user.email;
              }
              
              if (emailField.value) {
                emailField.readOnly = true;
              }
            }
            
            // Add a message above the form to show logged-in status
            const commentForm = document.getElementById("commentForm");
            if (commentForm && nameField.value && emailField.value) {
              const loggedInMsg = document.createElement("div");
              loggedInMsg.className = "logged-in-message";
              loggedInMsg.innerHTML = `<p>Commenting as <strong>${nameField.value}</strong> (${emailField.value})</p>`;
              loggedInMsg.style.backgroundColor = "#f8f8f8";
              loggedInMsg.style.padding = "10px";
              loggedInMsg.style.marginBottom = "15px";
              loggedInMsg.style.borderRadius = "4px";
              loggedInMsg.style.fontSize = "0.9em";
              
              // Remove existing message if present
              const existingMsg = document.querySelector(".logged-in-message");
              if (existingMsg) {
                existingMsg.parentNode.removeChild(existingMsg);
              }
              
              // Add the message before the form
              commentForm.parentNode.insertBefore(loggedInMsg, commentForm);
            }
          }
        } catch (error) {
          console.error("Error getting user data:", error);
        }
      } else {
        // User is signed out
        document.getElementById("login-link").style.display = "inline";
        document.getElementById("logout-btn").style.display = "none";
        document.getElementById("adminDashboard").style.display = "none";
        
        // Make sure form fields are editable
        const nameField = document.getElementById("name");
        const emailField = document.getElementById("email");
        
        if (nameField) nameField.readOnly = false;
        if (emailField) emailField.readOnly = false;
        
        // Remove the logged-in message if it exists
        const loggedInMsg = document.querySelector(".logged-in-message");
        if (loggedInMsg) {
          loggedInMsg.parentNode.removeChild(loggedInMsg);
        }
      }
    });

    // Handle logout
    document.getElementById("logout-btn").addEventListener("click", () => {
      auth.signOut().then(() => {
        window.location.href = "index.html";
      });
    });

    // 1. On DOM load, fetch and display the post (if postId is found in the URL).
    document.addEventListener("DOMContentLoaded", async () => {
      const urlParams = new URLSearchParams(window.location.search);
      const postId = urlParams.get("postId");

      if (!postId) {
        document.body.innerHTML = "<h2>Error: No post ID found.</h2>";
        return;
      }

      try {
        // Fetch the post from Firestore.
        const postRef = doc(db, "posts", postId);
        const postSnap = await getDoc(postRef);

        if (!postSnap.exists()) {
          document.body.innerHTML = "<h2>Error: Post not found.</h2>";
          return;
        }

        const postData = postSnap.data();

        // Populate the DOM with the post's details.
        document.title = postData.title + " - Makeup by NY";
        
        // Apply the title font if it exists
        const postHeading = document.getElementById("postHeading");
        if (postHeading && postData.titleFont) {
          // Apply the font with quotes to handle font names with spaces
          postHeading.style.fontFamily = `"${postData.titleFont}"`;
          console.log('Applied font:', postData.titleFont); // Debug log
        }
        // Set the title text content instead of innerHTML to prevent HTML entities from showing
        postHeading.textContent = postData.title;
        
        // Format and display the post date
        const postDateElement = document.getElementById("postDate");
        if (postDateElement && postData.postDate) {
          const date = new Date(postData.postDate);
          const options = { year: 'numeric', month: 'long', day: 'numeric' };
          postDateElement.textContent = date.toLocaleDateString('en-US', options);
        }
        
        document.getElementById("postContent").innerHTML = postData.content;

        // If there's an image, display it.
        if (postData.imageUrl) {
          const imgElement = document.getElementById("postImage");
          imgElement.src = postData.imageUrl;
          imgElement.style.display = "block";
        }

        // Once the post is loaded, also fetch & display any existing comments.
        await fetchAndDisplayComments(postId);

        // Load recent posts in the sidebar
        await loadRecentPosts();

      } catch (error) {
        console.error("Error fetching post:", error);
        document.body.innerHTML = "<h2>Error loading post.</h2>";
      }

      // 2. Handle the comment form submission.
      const commentForm = document.getElementById("commentForm");
      if (commentForm) {
        // Initialize the avatar preview
        initializeAvatarPreview();
        
        commentForm.addEventListener("submit", async (e) => {
          e.preventDefault();

          // Show loading state
          const submitBtn = commentForm.querySelector('button[type="submit"]');
          const originalBtnText = submitBtn.textContent;
          submitBtn.textContent = "Submitting...";
          submitBtn.disabled = true;

          // Gather comment data from the form.
          const commentText = document.getElementById("commentText").value;
          const commenterName = document.getElementById("name").value;
          const commenterEmail = document.getElementById("email").value;
          const avatarFile = document.getElementById("avatarUpload").files[0];

          // Basic check for a valid postId.
          if (!postId) {
            alert("Cannot post a comment without a valid Post ID!");
            resetSubmitButton();
            return;
          }

          try {
            // Upload avatar if provided
            let avatarUrl = null;
            if (avatarFile) {
              avatarUrl = await uploadAvatar(avatarFile, commenterEmail);
            }

            // Reference to subcollection: posts/{postId}/comments
            const commentsRef = collection(doc(db, "posts", postId), "comments");

            // Add the comment data, including a timestamp for ordering.
            await addDoc(commentsRef, {
              text: commentText,
              name: commenterName,
              email: commenterEmail,
              avatarUrl: avatarUrl,
              createdAt: serverTimestamp(),
              userId: auth.currentUser ? auth.currentUser.uid : null, // Store user ID if logged in
            });

            alert("Comment submitted!");
            commentForm.reset();
            
            // Reset avatar preview
            const avatarPreview = document.getElementById("avatarPreview");
            avatarPreview.innerHTML = `<span id="avatarInitial"></span>`;

            // Re-fetch comments so the user sees their new comment immediately.
            await fetchAndDisplayComments(postId);

          } catch (error) {
            console.error("Error submitting comment:", error);
            alert("Error submitting comment. Please try again.");
          } finally {
            // Reset button state
            resetSubmitButton();
          }
          
          function resetSubmitButton() {
            submitBtn.textContent = originalBtnText;
            submitBtn.disabled = false;
          }
        });
      }
    });

    // Initialize avatar preview functionality
    function initializeAvatarPreview() {
      const nameInput = document.getElementById('name');
      const avatarUpload = document.getElementById('avatarUpload');
      const avatarPreview = document.getElementById('avatarPreview');
      const avatarInitial = document.getElementById('avatarInitial');
      
      // Update avatar initial when name changes
      nameInput.addEventListener('input', () => {
        if (!avatarPreview.querySelector('img')) {
          const initial = nameInput.value.charAt(0).toUpperCase();
          avatarInitial.textContent = initial || '';
        }
      });
      
      // Handle file selection for avatar
      avatarUpload.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        // Validate file size (max 2MB)
        if (file.size > 2 * 1024 * 1024) {
          alert('Profile picture must be less than 2MB');
          avatarUpload.value = '';
          return;
        }
        
        // Validate file type
        const validTypes = ['image/jpeg', 'image/png', 'image/gif'];
        if (!validTypes.includes(file.type)) {
          alert('Please select a valid image file (JPEG, PNG, or GIF)');
          avatarUpload.value = '';
          return;
        }
        
        // Preview the image
        const reader = new FileReader();
        reader.onload = (evt) => {
          avatarPreview.innerHTML = `<img src="${evt.target.result}" alt="Avatar preview">`;
        };
        reader.readAsDataURL(file);
      });
    }
    
    // Function to upload avatar to storage
    async function uploadAvatar(file, userEmail) {
      try {
        // Import Firebase Storage
        const { getStorage, ref, uploadBytes, getDownloadURL } = await import("https://www.gstatic.com/firebasejs/10.8.1/firebase-storage.js");
        const storage = getStorage();
        
        // Create a unique filename
        const fileExtension = file.name.split('.').pop();
        const filename = `avatars/${userEmail.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}.${fileExtension}`;
        
        // Upload the file
        const storageRef = ref(storage, filename);
        await uploadBytes(storageRef, file);
        
        // Get the download URL
        const downloadURL = await getDownloadURL(storageRef);
        return downloadURL;
      } catch (error) {
        console.error('Error uploading avatar:', error);
        alert('Failed to upload profile picture. Comment will be posted without an avatar.');
        return null;
      }
    }

    // 3. Fetch and display comments in chronological order (newest first).
    async function fetchAndDisplayComments(postId) {
      const commentsContainer = document.getElementById("commentsContainer");
      if (!commentsContainer) return;

      // Clear existing comments from the container.
      commentsContainer.innerHTML = "";

      try {
        // Subcollection reference: posts/{postId}/comments
        const commentsRef = collection(doc(db, "posts", postId), "comments");
        const q = query(commentsRef, orderBy("createdAt", "desc"));
        const querySnapshot = await getDocs(q);

        if (querySnapshot.empty) {
          commentsContainer.innerHTML = "<p style='text-align: center; color: #666; font-style: italic;'>No comments yet. Be the first to share your thoughts!</p>";
          return;
        }

        // Create an object to store comment threads
        const commentThreads = {};
        
        // First pass - create all comment elements
        querySnapshot.forEach((commentDoc) => {
          const commentId = commentDoc.id;
          const commentData = commentDoc.data();
          
          // Store the comment in our threads object
          commentThreads[commentId] = {
            data: commentData,
            element: createCommentElement(commentData, commentId),
            replies: []
          };
          
          // If this is a reply to another comment, store that relationship
          if (commentData.parentId && commentThreads[commentData.parentId]) {
            commentThreads[commentData.parentId].replies.push(commentId);
          }
        });
        
        // Second pass - build the comment hierarchy
        for (const commentId in commentThreads) {
          const thread = commentThreads[commentId];
          
          // If this is a top-level comment (no parent), add it to the container
          if (!thread.data.parentId) {
            commentsContainer.appendChild(thread.element);
            
            // If this comment has replies, add them
            if (thread.replies.length > 0) {
              const replyList = document.createElement('div');
              replyList.className = 'reply-list';
              
              thread.replies.forEach(replyId => {
                replyList.appendChild(commentThreads[replyId].element);
              });
              
              thread.element.appendChild(replyList);
            }
          }
        }
      } catch (error) {
        console.error("Error fetching comments:", error);
        commentsContainer.innerHTML = "<p>Error loading comments.</p>";
      }
    }
    
    // Helper function to create a comment element
    function createCommentElement(commentData, commentId) {
      const commentElement = document.createElement("div");
      commentElement.className = "comment";
      commentElement.dataset.id = commentId;
      
      // Format the date
      let dateDisplay = "Just now";
      if (commentData.createdAt) {
        const date = commentData.createdAt.toDate();
        const now = new Date();
        const diffMs = now - date;
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
        
        if (diffDays < 1) {
          // Less than a day - show relative time
          const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
          if (diffHours < 1) {
            const diffMinutes = Math.floor(diffMs / (1000 * 60));
            dateDisplay = diffMinutes < 1 ? "Just now" : `${diffMinutes} minute${diffMinutes > 1 ? 's' : ''} ago`;
          } else {
            dateDisplay = `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
          }
        } else if (diffDays < 7) {
          // Less than a week - show days ago
          dateDisplay = `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
        } else {
          // More than a week - show formatted date
          dateDisplay = date.toLocaleDateString('en-US', { 
            year: 'numeric', 
            month: 'short', 
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
          });
        }
      }
      
      // Generate avatar content
      let avatarContent = '';
      if (commentData.avatarUrl) {
        avatarContent = `<img src="${commentData.avatarUrl}" alt="${commentData.name}'s avatar">`;
      } else {
        // Use first letter of name as avatar
        const initial = commentData.name.charAt(0).toUpperCase();
        avatarContent = initial;
      }
      
      // Build the comment HTML
      commentElement.innerHTML = `
        <div class="comment-header">
          <div class="comment-avatar">${avatarContent}</div>
          <div class="comment-info">
            <div class="comment-author">${commentData.name}</div>
            <div class="comment-date">${dateDisplay}</div>
          </div>
        </div>
        <div class="comment-content">${commentData.text}</div>
        <div class="comment-actions">
          <a href="#" class="comment-action reply-action" data-comment-id="${commentId}">Reply</a>
        </div>
        <div class="reply-form" id="replyForm-${commentId}">
          <textarea placeholder="Write your reply..." id="replyText-${commentId}"></textarea>
          <div class="reply-actions">
            <button class="reply-cancel" data-comment-id="${commentId}">Cancel</button>
            <button class="reply-submit" data-comment-id="${commentId}">Reply</button>
          </div>
        </div>
      `;
      
      // Add event listener for reply button
      const replyAction = commentElement.querySelector('.reply-action');
      replyAction.addEventListener('click', (e) => {
        e.preventDefault();
        toggleReplyForm(commentId);
      });
      
      // Add event listeners for reply form buttons
      const cancelButton = commentElement.querySelector('.reply-cancel');
      cancelButton.addEventListener('click', () => {
        toggleReplyForm(commentId, false);
      });
      
      const submitButton = commentElement.querySelector('.reply-submit');
      submitButton.addEventListener('click', () => {
        submitReply(commentId);
      });
      
      return commentElement;
    }
    
    // Toggle reply form visibility
    function toggleReplyForm(commentId, show) {
      const replyForm = document.getElementById(`replyForm-${commentId}`);
      if (!replyForm) return;
      
      if (show === undefined) {
        // Toggle visibility if not specified
        replyForm.classList.toggle('visible');
      } else if (show) {
        replyForm.classList.add('visible');
      } else {
        replyForm.classList.remove('visible');
      }
      
      // If showing the form, focus the textarea
      if (replyForm.classList.contains('visible')) {
        document.getElementById(`replyText-${commentId}`).focus();
      }
    }
    
    // Submit a reply to a comment
    async function submitReply(parentId) {
      const replyTextArea = document.getElementById(`replyText-${parentId}`);
      const replyText = replyTextArea.value.trim();
      
      if (!replyText) {
        alert('Please enter a reply');
        return;
      }
      
      // Get current user name and email if available, otherwise prompt
      let name = document.getElementById('name').value;
      let email = document.getElementById('email').value;
      
      if (!name || !email) {
        // Check if user is logged in
        const currentUser = auth.currentUser;
        if (currentUser) {
          try {
            // Get user data from Firestore
            const userRef = doc(db, "users", currentUser.uid);
            const userDoc = await getDoc(userRef);
            
            if (userDoc.exists()) {
              const userData = userDoc.data();
              if (userData.username) {
                name = userData.username;
              } else if (userData.firstName) {
                name = `${userData.firstName} ${userData.lastName || ''}`.trim();
              }
              
              if (userData.email) {
                email = userData.email;
              } else if (currentUser.email) {
                email = currentUser.email;
              }
            } else if (currentUser.email) {
              // If no Firestore data, fallback to auth data
              email = currentUser.email;
              name = email.split('@')[0]; // Use part of email as name
            }
          } catch (error) {
            console.error("Error getting user data for reply:", error);
          }
        }
        
        // If still no name/email, prompt user
        if (!name) name = prompt('Please enter your name');
        if (!email) email = prompt('Please enter your email');
        
        if (!name || !email) {
          alert('Name and email are required to submit a reply');
          return;
        }
      }
      
      try {
        // Get the post ID from the URL
        const urlParams = new URLSearchParams(window.location.search);
        const postId = urlParams.get("postId");
        
        if (!postId) {
          alert('Error: Cannot identify the post');
          return;
        }
        
        // Reference to subcollection: posts/{postId}/comments
        const commentsRef = collection(doc(db, "posts", postId), "comments");
        
        // Add the reply as a new comment with parentId reference
        await addDoc(commentsRef, {
          text: replyText,
          name: name,
          email: email,
          parentId: parentId,
          createdAt: serverTimestamp(),
          userId: auth.currentUser ? auth.currentUser.uid : null, // Store user ID if logged in
        });
        
        // Hide the reply form
        toggleReplyForm(parentId, false);
        
        // Refresh comments
        await fetchAndDisplayComments(postId);
        
        alert('Reply submitted!');
      } catch (error) {
        console.error('Error submitting reply:', error);
        alert('Error submitting reply. Please try again.');
      }
    }

    // 4. Load recent posts in the sidebar
    async function loadRecentPosts() {
      const recentPostsList = document.getElementById("recentPostsList");
      if (!recentPostsList) return;

      try {
        const q = query(collection(db, "posts"), orderBy("createdAt", "desc"));
        const querySnapshot = await getDocs(q);
        
        // Clear existing posts
        recentPostsList.innerHTML = "";
        
        // Add the first 5 posts
        querySnapshot.docs.slice(0, 5).forEach(doc => {
          const post = doc.data();
          const recentPostElement = document.createElement("a");
          recentPostElement.href = `post.html?postId=${doc.id}`;
          recentPostElement.className = "recent-post-item";
          
          // Create thumbnail image or placeholder
          const imageHtml = post.imageUrl 
            ? `<img src="${post.imageUrl}" alt="${post.title}">`
            : `<div style="width: 60px; height: 60px; background-color: #f0f0f0; border-radius: 8px;"></div>`;
          
          recentPostElement.innerHTML = `
            ${imageHtml}
            <div class="post-title">${post.title}</div>
          `;
          
          recentPostsList.appendChild(recentPostElement);
        });
      } catch (error) {
        console.error("Error loading recent posts:", error);
        recentPostsList.innerHTML = "<p>Error loading recent posts.</p>";
      }
    }
  </script>
</body>
</html>
