<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Post - Makeup by NY</title>
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <!-- Add Google Fonts for Cursive Options -->
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script&family=Great+Vibes&family=Pacifico&family=Satisfy&family=Allura&family=Tangerine&family=Pinyon+Script&family=Alex+Brush&display=swap" rel="stylesheet">
  <style>
    .content {
      display: flex;
      gap: 2rem;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    main {
      flex: 1;
      max-width: 800px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    article {
      width: 100%;
      text-align: center;
    }

    article h2 {
      margin-bottom: 20px;
    }

    article img {
      max-width: 100%;
      height: auto;
      margin: 20px auto;
      display: block;
      border-radius: 8px;
    }

    article p {
      text-align: left;
      line-height: 1.6;
      margin: 20px 0;
    }

    section {
      width: 100%;
      max-width: 600px;
      margin: 0 auto;
    }

    section h3, section h2 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 1.5em;
      position: relative;
    }
    
    section h3::after, section h2::after {
      content: "";
      display: block;
      width: 30%;
      height: 1px;
      background-color: #000;
      margin: 10px auto;
    }

    /* New comment form styling */
    #commentForm {
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 500px;
      margin: 0 auto;
      background-color: #f9f9f9;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      box-sizing: border-box;
    }

    #commentForm label {
      font-size: 0.85em;
      font-weight: bold;
      margin-bottom: 5px;
      color: #222;
    }

    #commentForm textarea {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-bottom: 15px;
      font-family: inherit;
      font-size: 0.95em;
      transition: border-color 0.3s;
      box-sizing: border-box;
      min-height: 120px;
      max-height: 200px;
      resize: vertical;
      overflow-y: auto;
      line-height: 1.4;
    }
    
    #commentForm textarea:focus {
      border-color: #222;
      outline: none;
    }

    #commentForm button {
      align-self: flex-end;
      padding: 8px 16px;
      background: transparent;
      border: 2px solid #222;
      color: #222;
      font-size: 14px;
      font-weight: bold;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    #commentForm button:hover {
      background: #222;
      color: white;
    }
    
    /* Comment display styles */
    #commentsContainer {
      margin: 30px 0;
    }
    
    .comment {
      padding: 15px;
      border-bottom: 1px solid #eee;
      margin-bottom: 15px;
      transition: background-color 0.2s;
    }
    
    .comment:hover {
      background-color: #f9f9f9;
    }
    
    .comment:last-child {
      border-bottom: none;
    }
    
    .comment-header {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .comment-avatar-container {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 12px;
    }
    
    .comment-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: #f0f0f0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: #555;
      flex-shrink: 0;
      overflow: hidden;
      position: relative;
    }
    
    .comment-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      margin: auto;
    }
    
    .comment-info {
      flex: 1;
    }
    
    .comment-author {
      font-weight: bold;
      color: #333;
      margin-bottom: 3px;
      font-size: 0.95em;
    }

    .comment-date {
      color: #888;
      font-size: 0.85em;
    }
    
    .comment-content {
      margin: 0 0 15px 52px;
      line-height: 1.5;
      font-size: 0.95em;
    }
    
    .comment-actions {
      margin-left: 52px;
      display: flex;
      gap: 15px;
    }
    
    .comment-action {
      font-size: 0.85em;
      color: #666;
      cursor: pointer;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
    }
    
    .comment-action:hover {
      color: #222;
      text-decoration: underline;
    }
    
    /* Reply styling */
    .reply-list {
      margin: 10px 0 0 45px;
      padding-left: 15px;
      border-left: 2px solid #ddd;
      position: relative;
      transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
      overflow: hidden;
      max-height: 1000px; /* Default expanded state */
      opacity: 1;
    }
    
    .reply-list.collapsed {
      max-height: 0;
      opacity: 0;
      margin-top: 0;
      margin-bottom: 0;
      padding-top: 0;
      padding-bottom: 0;
    }
    
    .reply-list:before {
      content: "Replies";
      position: absolute;
      top: -10px;
      left: 0;
      font-size: 0.8em;
      color: #888;
      background-color: #fff;
      padding: 0 5px;
      transform: translateX(-50%);
      transition: opacity 0.2s ease;
    }
    
    .reply-list.collapsed:before {
      opacity: 0;
    }
    
    .toggle-replies {
      font-size: 0.85em;
      color: #666;
      cursor: pointer;
      margin-left: 52px;
      display: inline-flex;
      align-items: center;
      user-select: none;
      margin-top: 5px;
      margin-bottom: 10px;
    }
    
    .toggle-replies.collapsed {
      margin-bottom: 15px;
    }
    
    .toggle-replies:hover {
      color: #333;
    }
    
    .toggle-replies .toggle-icon {
      display: inline-block;
      margin-right: 4px;
      transition: transform 0.2s ease;
    }
    
    .toggle-replies.collapsed .toggle-icon {
      transform: rotate(-90deg);
    }
    
    .reply-count {
      background-color: #f0f0f0;
      border-radius: 10px;
      padding: 1px 6px;
      font-size: 0.85em;
      color: #666;
      margin-left: 5px;
      display: inline-block;
    }
    
    .reply-comment {
      position: relative;
      background-color: #f8f8f8;
      border-radius: 8px;
      margin-bottom: 10px;
      padding: 12px;
    }
    
    .reply-comment:before {
      content: "";
      position: absolute;
      top: 15px;
      left: -17px;
      width: 15px;
      height: 2px;
      background-color: #ddd;
    }
    
    .reply-form {
      margin: 15px 0 15px 52px;
      display: none;
      background-color: #f5f5f5;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
      transition: all 0.2s ease;
    }
    
    .reply-form.visible {
      display: block;
    }
    
    .reply-form textarea {
      width: 100%;
      min-height: 80px;
      resize: vertical;
      padding: 10px;
      margin-bottom: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: inherit;
      font-size: 0.95em;
    }
    
    .reply-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    
    .reply-actions button {
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 0.9em;
      cursor: pointer;
    }
    
    .reply-cancel {
      background: none;
      border: 1px solid #ddd;
    }
    
    .reply-submit {
      background: #333;
      color: white;
      border: none;
    }
    
    .reply-cancel:hover {
      background: #f5f5f5;
    }
    
    .reply-submit:hover {
      background: #444;
    }

    .about-me {
      width: 300px;
      flex-shrink: 0;
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .profile-pic {
      width: 150px;
      height: 150px;
      border-radius: 50%;
      margin-bottom: 20px;
      display: block;
      margin-left: auto;
      margin-right: auto;
    }

    .search-container {
      margin: 20px 0;
    }

    .search-container input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .recent-posts {
      margin: 20px 0;
    }

    .recent-post-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 0;
      text-decoration: none;
      color: inherit;
    }

    .recent-post-item img {
      width: 60px;
      height: 60px;
      object-fit: cover;
      border-radius: 4px;
    }

    .post-title {
      font-size: 0.9em;
      line-height: 1.4;
    }

    .social-links {
      margin-top: 20px;
    }

    .social-icons {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .social-icon {
      padding: 8px 15px;
      background: #f0f0f0;
      border-radius: 4px;
      text-decoration: none;
      color: #333;
      font-size: 0.9em;
    }

    @media (max-width: 768px) {
      .content {
        flex-direction: column;
        padding: 15px;
        gap: 1.5rem;
      }
      
      .about-me {
        width: 100%;
        margin-top: 20px;
        display: none; /* Hide about-me section on mobile */
      }

      main {
        width: 100%;
        max-width: 100%;
        padding: 0;
      }

      article {
        width: 100%;
      }

      #postHeading {
        font-size: 2.8em;
      }

      article p {
        font-size: 1.1em;
        line-height: 1.7;
      }

      section {
        width: 100%;
        max-width: 100%;
      }

      #commentForm {
        max-width: 100%;
      }
    }

    .comments-section {
      margin-top: 40px;
      padding: 20px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .comments-section h2 {
      margin-bottom: 20px;
      color: #333;
      font-size: 1.5em;
    }

    .comment {
      padding: 15px;
      border-bottom: 1px solid #eee;
      margin-bottom: 15px;
    }

    .comment:last-child {
      border-bottom: none;
    }

    .comment-header {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }

    .comment-author {
      font-weight: bold;
      color: #333;
      margin-right: 10px;
    }

    .comment-date {
      color: #666;
      font-size: 0.9em;
    }

    .comment-content {
      color: #444;
      line-height: 1.5;
      margin: 0;
    }

    .comment-form {
      margin-top: 30px;
    }

    .comment-form h3 {
      margin-bottom: 15px;
      color: #333;
      font-size: 1.2em;
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-group label {
      display: block;
      margin-bottom: 5px;
      color: #333;
      font-weight: 500;
    }

    .form-group input,
    .form-group textarea {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 0.95em;
    }

    .form-group textarea {
      min-height: 100px;
      resize: vertical;
    }

    .submit-btn {
      background: #333;
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.95em;
      transition: background 0.3s;
    }

    .submit-btn:hover {
      background: #444;
    }

    .no-comments {
      color: #666;
      font-style: italic;
      margin: 20px 0;
    }

    /* Add these styles to ensure proper font display */
    #postHeading {
      font-size: 2.5em;
      margin-bottom: 1em;
      line-height: 1.3;
      overflow-wrap: break-word;
      word-wrap: break-word;
      word-break: break-word;
      hyphens: auto;
    }

    /* Add specific font styles */
    #postHeading[style*="font-family: 'Dancing Script'"],
    #postHeading[style*="font-family: Dancing Script"] {
      font-family: 'Dancing Script', cursive !important;
    }
    
    #postHeading[style*="font-family: 'Great Vibes'"],
    #postHeading[style*="font-family: Great Vibes"] {
      font-family: 'Great Vibes', cursive !important;
    }
    
    #postHeading[style*="font-family: 'Pacifico'"],
    #postHeading[style*="font-family: Pacifico"] {
      font-family: 'Pacifico', cursive !important;
    }
    
    #postHeading[style*="font-family: 'Satisfy'"],
    #postHeading[style*="font-family: Satisfy"] {
      font-family: 'Satisfy', cursive !important;
    }
    
    #postHeading[style*="font-family: 'Allura'"],
    #postHeading[style*="font-family: Allura"] {
      font-family: 'Allura', cursive !important;
    }
    
    #postHeading[style*="font-family: 'Brush Script MT'"],
    #postHeading[style*="font-family: Brush Script MT"] {
      font-family: 'Brush Script MT', cursive !important;
    }
    
    #postHeading[style*="font-family: 'Tangerine'"],
    #postHeading[style*="font-family: Tangerine"] {
      font-family: 'Tangerine', cursive !important;
    }
    
    #postHeading[style*="font-family: 'Alex Brush'"],
    #postHeading[style*="font-family: Alex Brush"] {
      font-family: 'Alex Brush', cursive !important;
    }
    
    #postHeading[style*="font-family: 'Pinyon Script'"],
    #postHeading[style*="font-family: Pinyon Script"] {
      font-family: 'Pinyon Script', cursive !important;
    }

    #loginToComment {
      text-align: center;
      padding: 20px;
      background-color: #f9f9f9;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    #loginToComment p {
      margin-bottom: 15px;
    }
    
    #loginToComment a {
      display: inline-block;
      padding: 8px 16px;
      background: transparent;
      border: 2px solid #222;
      color: #222;
      font-size: 14px;
      font-weight: bold;
      border-radius: 4px;
      text-decoration: none;
      transition: all 0.3s ease;
    }
    
    #loginToComment a:hover {
      background: #222;
      color: white;
    }

    /* Notification styling */
    .notification {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 12px 20px;
      border-radius: 4px;
      color: white;
      font-size: 14px;
      font-weight: 500;
      box-shadow: 0 3px 10px rgba(0,0,0,0.15);
      z-index: 9999;
      opacity: 0;
      transform: translateY(20px);
      animation: slideIn 0.3s forwards, fadeOut 0.5s 2.5s forwards;
    }

    .notification.success {
      background-color: #4CAF50;
    }

    .notification.error {
      background-color: #F44336;
    }

    @keyframes slideIn {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes fadeOut {
      to {
        opacity: 0;
        transform: translateY(20px);
      }
    }

    /* Responsive adjustments for comments */
    @media (max-width: 480px) {
      .comment-avatar {
        width: 35px;
        height: 35px;
      }
      
      .comment-content {
        margin-left: 47px;
      }
      
      .comment-actions {
        margin-left: 47px;
      }
      
      .reply-form {
        margin-left: 47px;
      }
      
      .reply-list {
        margin-left: 35px;
      }
      
      .toggle-replies {
        margin-left: 47px;
        font-size: 0.8em;
      }
    }

    /* Styles for orphaned replies */
    .orphaned-reply {
      border-left: 2px dashed #999;
      padding-left: 10px;
    }
    
    .orphaned-reply-note {
      font-size: 0.8em;
      color: #666;
      font-style: italic;
      margin-bottom: 8px;
      background-color: #f5f5f5;
      padding: 4px 8px;
      border-radius: 4px;
    }
    
    /* Dropdown Menu Styling */
    .dropdown {
      position: relative;
      display: inline-block;
    }
    
    .dropbtn {
      background-color: transparent;
      color: inherit;
      padding: 0;
      font-family: inherit;
      font-size: inherit;
      border: none;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
    }
    
    .dropdown-content {
      display: none;
      position: absolute;
      background-color: #f9f9f9;
      min-width: 160px;
      box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
      z-index: 1;
      border-radius: 4px;
    }
    
    .dropdown-content a {
      color: black;
      padding: 12px 16px;
      text-decoration: none;
      display: block;
      text-align: left;
    }
    
    .dropdown-content a:hover {
      background-color: #f1f1f1;
    }
    
    .dropdown:hover .dropdown-content {
      display: block;
    }
    
    /* Admin Dropdown Menu Styles */
    .admin-dropdown {
      position: relative;
      display: inline-block;
      vertical-align: middle;
      margin-bottom: -5px;
    }

    .admin-dropdown-btn {
      background: none;
      border: none;
      color: #333;
      font-size: 1em;
      padding: 10px 0;
      margin-bottom: 0;
      cursor: pointer;
      font-family: inherit;
      text-decoration: none;
      display: flex;
      align-items: center;
      transition: color 0.2s;
    }
    
    /* Fix navigation spacing */
    #mainNav {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      gap: 5px;
      margin-top: -5px;
    }
    
    #mainNav a, #mainNav button {
      margin: 0 10px;
      padding: 3px 0;
    }

    /* Ensure second row is closer to first row */
    #myAccount, #login-link, #logout-btn {
      margin-top: -5px !important;
    }

    .admin-dropdown-btn .dropdown-icon {
      display: inline-block;
      margin-left: 5px;
      transition: transform 0.3s ease;
    }

    .admin-dropdown-btn.active .dropdown-icon {
      transform: rotate(180deg);
    }

    .admin-dropdown-btn:hover, 
    .admin-dropdown-btn.active {
      color: #a07;
    }

    .admin-dropdown-content {
      display: none;
      position: absolute;
      left: 0;
      top: 100%;
      background-color: white;
      min-width: 180px;
      box-shadow: 0 8px 16px rgba(0,0,0,0.1);
      z-index: 1000;
      border-radius: 4px;
      overflow: visible;
      margin-top: 0;
      border: 1px solid #eee;
    }

    .admin-dropdown-content a {
      color: #333;
      padding: 12px 16px;
      text-decoration: none;
      display: block;
      text-align: left;
      transition: background-color 0.2s, color 0.2s;
      border-bottom: 1px solid #f5f5f5;
    }

    .admin-dropdown-content a:last-child {
      border-bottom: none;
    }

    .admin-dropdown-content a:hover {
      background-color: #f9f9f9;
      color: #a07;
    }

    /* This class is toggled via JavaScript */
    .show-dropdown {
      display: block !important;
      opacity: 1 !important;
      transform: none !important;
      visibility: visible !important;
    }

    /* Responsive adjustments for admin dropdown */
    @media (max-width: 768px) {
      .admin-dropdown-content {
        position: absolute;
        right: 0;
        left: auto;
        width: 200px;
      }
    }

    /* For very small screens */
    @media (max-width: 480px) {
      .admin-dropdown-content {
        max-height: 80vh; /* Limit maximum height and add scrolling if needed */
        overflow-y: auto;
        width: 180px; /* Fixed width to ensure content fits */
        position: fixed !important; /* Use fixed positioning for mobile */
        /* Top and left values will be set by JavaScript */
        transform: none !important; /* No transform needed */
        z-index: 9999 !important; /* Super high z-index to ensure it appears above everything */
        background-color: white !important; /* Ensure background is opaque */
        box-shadow: 0 8px 16px rgba(0,0,0,0.2) !important; /* Stronger shadow for better visibility */
        border: 1px solid #ddd !important; /* More visible border */
        display: none; /* Hide by default */
      }
      
      /* When shown, make sure it's visible */
      .admin-dropdown-content.show-dropdown,
      .admin-dropdown-content[style*="display: block"] {
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
      }
      
      /* Fix for dropdown positioning - ensure it's visible on mobile */
      .admin-dropdown {
        position: relative !important; /* Use relative for proper positioning */
        vertical-align: middle !important;
        margin-top: 5px !important;
        display: inline-block !important;
      }
      
      /* Make dropdown items more touch-friendly on mobile */
      .admin-dropdown-content a {
        padding: 15px 16px !important; /* Larger touch targets */
        font-size: 0.95em !important; /* Slightly larger text */
        border-bottom: 1px solid #eee !important; /* More visible separators */
        text-align: left !important; /* Left-align the text */
        display: block !important; /* Ensure block display */
      }
    }

    /* Header and navigation layout */
    header {
      margin-bottom: 10px;
    }
    
    .header-content {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    /* Logo styling to ensure proper size */
    .logo {
      min-width: 610px;
      width: 610px;
      margin: 0 auto;
    }
    
    .logo img {
      width: 100%;
      max-width: 610px;
      height: auto;
      object-fit: contain;
    }
  </style>
</head>
<body>
  <header>
    <a href="index.html">
      <img src="nbvlogo.png" alt="Ny's Beauty Vault Logo" style="width: 100%; max-width: 610px; height: auto; object-fit: contain;">
    </a>
    <nav id="mainNav" style="margin-top: 10px; width: 100%;">
      <a href="index.html">Home</a>
      <a href="about.html">About</a>
      <a href="contact.html">Contact</a>
      <!-- Admin dropdown menu (initially hidden) -->
      <div class="admin-dropdown" style="position: relative;">
          <a id="adminDropdownBtn" class="admin-dropdown-btn" href="#" style="display:none; position: relative !important; top: -4px !important; margin-top: 0 !important; margin-bottom: 0 !important; padding-bottom: 0 !important; font-family: inherit !important; font-weight: normal !important; font-size: 0.85em !important;">
              Admin Dashboard 
              <span class="dropdown-icon">▼</span>
          </a>
          <div id="adminDropdownContent" class="admin-dropdown-content" style="position: absolute; top: 100%; left: 0; z-index: 1000; display: none;">
              <a href="admin-dashboard.html">Messages</a>
              <a href="editor.html">Create Post</a>
              <a href="edit-post.html">Edit Posts</a>
              <a href="manage-users.html">User Management</a>
          </div>
      </div>
      <!-- User account link (initially hidden) -->
      <a id="myAccount" href="settings.html" style="display:none; margin-top: 0; padding-top: 0;">My Account</a>
      <!-- Public links -->
      <a id="login-link" href="login.html" style="margin-top: 0; padding-top: 0;">Login</a>
      <button id="logout-btn" style="display:none; margin-top: 0; padding-top: 0;">Logout</button>
    </nav>
  </header>

  <div class="content">
    <main>
      <article>
        <h2 id="postHeading">Post Content</h2>
        <hr style="width: 30%; margin: 10px auto; border-top: 1px solid #000; border-bottom: none;">
        <p id="postDate" class="post-date" style="color: #666; font-size: 0.9em; margin-bottom: 20px; text-align: center; font-style: italic;"></p>
        <img id="postImage" style="max-width: 100%; display: none;" alt="Post Image" />
        <p id="postContent">Fetching post...</p>
      </article>

      <!-- Comments Section -->
      <section>
        <h3>Comments</h3>
        <!-- Existing comments will be appended here -->
        <div id="commentsContainer"></div>

        <h2 id="leaveReplyHeading">Leave a Reply</h2>

        <!-- Login required message (shown when user is not logged in) -->
        <div id="loginToComment">
          <p>Please log in to leave a comment</p>
          <a href="login.html">Login</a>
        </div>

        <!-- Comment form (only shown when user is logged in) -->
        <form id="commentForm" style="display: none;">
          <label for="commentText">Comment*</label>
          <textarea id="commentText" name="commentText" placeholder="Share your thoughts..." required></textarea>
          
          <button type="submit">Post Comment</button>
        </form>
      </section>
    </main>

    <!-- About Me Sidebar -->
    <aside class="about-me">
      <img src="nyredhair.jpg" alt="Ny Red Hair" class="profile-pic">

      <p>
        Hello and welcome to my Makeup and Beauty Blog! I'm Ny, an aspiring makeup artist who's absolutely head-over-heels for all things beauty.
      </p>
      <p>
        Dive into honest product rundowns, foolproof tutorials, and the latest beauty buzz—like a monthly magazine come to life, but with my personal spin (and the occasional cameo from my family). Enjoy!
      </p>

      <!-- Social Media Links -->
      <div class="social-links">
        <h3 style="font-size: 1.1em; margin: 20px 0 10px;">Follow Me</h3>
        <div class="social-icons">
          <a href="https://www.instagram.com/_ryymone?igsh=N2M5azhzZ3h3ZzJl" class="social-icon instagram"><i class="fab fa-instagram"></i> Instagram</a>
          <a href="https://www.facebook.com/nyisha.rymone.1?mibextid=wwXIfr&rdid=AnupCw1sMQ1JiIU2&share_url=https%3A%2F%2Fwww.facebook.com%2Fshare%2F1AGiUj9TMu%2F%3Fmibextid%3DwwXIfr" class="social-icon facebook"><i class="fab fa-facebook-f"></i> Facebook</a>
        </div>
      </div>

      <!-- Search Bar -->
      <div class="search-container">
        <input type="text" placeholder="Search posts..." id="searchInput">
      </div>

      <!-- Recent Posts -->
      <div class="recent-posts">
        <h3 style="font-size: 1.1em; margin: 20px 0 10px;">Recent Posts</h3>
        <div id="recentPostsList"></div>
      </div>
    </aside>
  </div>

  <footer>
    <p>&copy; 2025 Makeup by NY</p>
  </footer>

  <!-- Main script block -->
  <script type="module">
    import {
      doc,
      getDoc,
      collection,
      addDoc,
      getDocs,
      query,
      orderBy,
      serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js";
    import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-auth.js";
    import { db, auth } from "./firebase-config.js";

    // Define admin user ID
    const adminUID = "yuoaYY14sINHaqtNK5EAz4nl8cc2";

    // Check authentication state
    onAuthStateChanged(auth, (user) => {
      if (user) {
        // User is signed in
        document.getElementById("login-link").style.display = "none";
        document.getElementById("logout-btn").style.display = "inline";
        document.getElementById("myAccount").style.display = "inline";
        
        // Check if user is admin
        if (user.uid === adminUID) {
          document.getElementById("adminDropdownBtn").style.display = "inline-block";
        } else {
          document.getElementById("adminDropdownBtn").style.display = "none";
        }
      } else {
        // User is signed out
        document.getElementById("login-link").style.display = "inline";
        document.getElementById("logout-btn").style.display = "none";
        document.getElementById("adminDropdownBtn").style.display = "none";
        document.getElementById("myAccount").style.display = "none";
      }
    });

    // Handle logout
    document.getElementById("logout-btn").addEventListener("click", () => {
      auth.signOut().then(() => {
        window.location.href = "index.html";
      });
    });

    // 1. On DOM load, fetch and display the post (if postId is found in the URL).
    document.addEventListener("DOMContentLoaded", async () => {
      const urlParams = new URLSearchParams(window.location.search);
      const postId = urlParams.get("postId");

      if (!postId) {
        document.body.innerHTML = "<h2>Error: No post ID found.</h2>";
        return;
      }

      try {
        // Fetch the post from Firestore.
        const postRef = doc(db, "posts", postId);
        const postSnap = await getDoc(postRef);

        if (!postSnap.exists()) {
          document.body.innerHTML = "<h2>Error: Post not found.</h2>";
          return;
        }

        const postData = postSnap.data();

        // Populate the DOM with the post's details.
        document.title = postData.title + " - Makeup by NY";
        
        // Apply the title font if it exists
        const postHeading = document.getElementById("postHeading");
        if (postHeading && postData.titleFont) {
          // Apply the font with quotes to handle font names with spaces
          postHeading.style.fontFamily = `"${postData.titleFont}"`;
          console.log('Applied font:', postData.titleFont); // Debug log
        }
        // Set the title text content instead of innerHTML to prevent HTML entities from showing
        postHeading.textContent = postData.title;
        
        // Format and display the post date
        const postDateElement = document.getElementById("postDate");
        if (postDateElement && postData.postDate) {
          const date = new Date(postData.postDate);
          const options = { year: 'numeric', month: 'long', day: 'numeric' };
          postDateElement.textContent = date.toLocaleDateString('en-US', options);
        }
        
        document.getElementById("postContent").innerHTML = postData.content;

        // If there's an image, display it.
        if (postData.imageUrl) {
          const imgElement = document.getElementById("postImage");
          imgElement.src = postData.imageUrl;
          imgElement.style.display = "block";
        }

        // Once the post is loaded, also fetch & display any existing comments.
        await fetchAndDisplayComments(postId);

        // Load recent posts in the sidebar
        await loadRecentPosts();

      } catch (error) {
        console.error("Error fetching post:", error);
        document.body.innerHTML = "<h2>Error loading post.</h2>";
      }

      // Handle authentication state change
      onAuthStateChanged(auth, async (user) => {
        const commentForm = document.getElementById("commentForm");
        const loginToComment = document.getElementById("loginToComment");
        
        if (user) {
          // User is signed in - show comment form and hide login message
          commentForm.style.display = "flex";
          loginToComment.style.display = "none";
          
          // Show the "Leave a Reply" heading for signed-in users
          document.getElementById("leaveReplyHeading").style.display = "block";
          
          // Listen for comment form submission
          commentForm.addEventListener("submit", async (e) => {
            e.preventDefault();

            // Show loading state
            const submitBtn = commentForm.querySelector('button[type="submit"]');
            const originalBtnText = submitBtn.textContent;
            submitBtn.textContent = "Submitting...";
            submitBtn.disabled = true;

            // Gather comment data from the form
            const commentText = document.getElementById("commentText").value;

            try {
              // Get user data from Firestore
              const userRef = doc(db, "users", user.uid);
              const userSnap = await getDoc(userRef);
              
              if (!userSnap.exists()) {
                alert("Could not retrieve your user profile. Please try again.");
                resetSubmitButton();
                return;
              }
              
              const userData = userSnap.data();
              
              // Reference to subcollection: posts/{postId}/comments
              const commentsRef = collection(doc(db, "posts", postId), "comments");

              // Add the comment data with user information
              await addDoc(commentsRef, {
                text: commentText,
                name: userData.username || user.displayName || 'User',
                email: user.email,
                avatarUrl: userData.avatarUrl,
                userId: user.uid,
                createdAt: serverTimestamp(),
              });

              alert("Comment submitted!");
              commentForm.reset();
              
              // Re-fetch comments so the user sees their new comment immediately
              await fetchAndDisplayComments(postId);

            } catch (error) {
              console.error("Error submitting comment:", error);
              alert("Error submitting comment. Please try again.");
            } finally {
              // Reset button state
              resetSubmitButton();
            }
            
            function resetSubmitButton() {
              submitBtn.textContent = originalBtnText;
              submitBtn.disabled = false;
            }
          });
        } else {
          // User is not signed in - hide comment form and show login message
          commentForm.style.display = "none";
          loginToComment.style.display = "block";
          
          // Hide the "Leave a Reply" heading for non-signed-in users
          document.getElementById("leaveReplyHeading").style.display = "none";
        }
      });
    });

    // 3. Fetch and display comments in chronological order (newest first).
    async function fetchAndDisplayComments(postId) {
      const commentsContainer = document.getElementById("commentsContainer");
      if (!commentsContainer) return;

      // Clear existing comments from the container.
      commentsContainer.innerHTML = "";
      console.log("Fetching comments for post:", postId);

      try {
        // Subcollection reference: posts/{postId}/comments
        const commentsRef = collection(doc(db, "posts", postId), "comments");
        const q = query(commentsRef, orderBy("createdAt", "desc"));
        const querySnapshot = await getDocs(q);

        console.log(`Found ${querySnapshot.size} comments total`);

        if (querySnapshot.empty) {
          commentsContainer.innerHTML = "<p style='text-align: center; color: #666; font-style: italic;'>No comments yet. Be the first to share your thoughts!</p>";
          return;
        }

        // Create an object to store comment threads
        const commentThreads = {};
        const topLevelComments = [];
        
        // First pass - gather all comments
        querySnapshot.forEach((commentDoc) => {
          const commentId = commentDoc.id;
          const commentData = commentDoc.data();
          
          // Add the ID to the comment data so it's accessible within the element
          commentData.id = commentId;
          
          console.log(`Processing comment: ${commentId}, parentId: ${commentData.parentId || 'none'}`);
          
          // Store the comment in our threads object
          commentThreads[commentId] = {
            data: commentData,
            element: createCommentElement(commentData, Boolean(commentData.parentId)),
            replies: []
          };
          
          // If it's a top-level comment, add to that array
          if (!commentData.parentId) {
            topLevelComments.push(commentId);
          }
        });
        
        console.log(`Found ${topLevelComments.length} top-level comments`);
        
        // Organize replies under their parents
        for (const commentId in commentThreads) {
          const comment = commentThreads[commentId].data;
          
          // If this is a reply (has a parentId) and the parent exists
          if (comment.parentId && commentThreads[comment.parentId]) {
            // Add this comment as a reply to its parent
            commentThreads[comment.parentId].replies.push(commentId);
            console.log(`Added comment ${commentId} as reply to ${comment.parentId}`);
          }
        }
        
        // Display top-level comments first (newest first)
        topLevelComments.forEach(commentId => {
          // Append the comment to the container
          commentsContainer.appendChild(commentThreads[commentId].element);
          
          // Check if this comment has replies
          if (commentThreads[commentId].replies.length > 0) {
            console.log(`Comment ${commentId} has ${commentThreads[commentId].replies.length} replies`);
            
            const replyList = document.createElement('div');
            replyList.className = 'reply-list collapsed'; // Start collapsed
            
            // Add each reply
            commentThreads[commentId].replies.forEach(replyId => {
              replyList.appendChild(commentThreads[replyId].element);
            });
            
            // Create toggle button for replies
            const replyCount = commentThreads[commentId].replies.length;
            const toggleButton = document.createElement('div');
            toggleButton.className = 'toggle-replies collapsed'; // Start with collapsed class
            toggleButton.innerHTML = `
              <span class="toggle-icon">▼</span> 
              <span>Show replies</span>
              <span class="reply-count">${replyCount}</span>
            `;
            toggleButton.dataset.commentId = commentId;
            
            // Add toggle functionality
            toggleButton.addEventListener('click', () => {
              const isCollapsed = replyList.classList.toggle('collapsed');
              const textSpan = toggleButton.querySelector('span:nth-child(2)');
              
              if (isCollapsed) {
                textSpan.textContent = 'Show replies';
                toggleButton.classList.add('collapsed');
              } else {
                textSpan.textContent = 'Hide replies';
                toggleButton.classList.remove('collapsed');
              }
            });
            
            // Add the toggle button before the reply list
            commentThreads[commentId].element.appendChild(toggleButton);
            
            // Append all replies to the parent comment
            commentThreads[commentId].element.appendChild(replyList);
          }
        });
        
        // Handle orphaned replies (replies to comments that no longer exist)
        for (const commentId in commentThreads) {
          const comment = commentThreads[commentId].data;
          
          // If it has a parentId but that parent doesn't exist or we don't have it
          if (comment.parentId && !commentThreads[comment.parentId]) {
            console.log(`Comment ${commentId} has orphaned parentId: ${comment.parentId}`);
            // Convert it to a top-level comment by removing the reply styling
            const element = commentThreads[commentId].element;
            element.classList.remove('reply-comment');
            element.classList.add('orphaned-reply');
            
            // Add a note that this was a reply to a deleted comment
            const noteElement = document.createElement('div');
            noteElement.className = 'orphaned-reply-note';
            noteElement.textContent = 'This was a reply to a comment that no longer exists.';
            element.insertBefore(noteElement, element.firstChild);
            
            // We don't add reply functionality to orphaned replies to maintain one level of nesting
            
            // Add it to the container
            commentsContainer.appendChild(element);
          }
        }
      } catch (error) {
        console.error("Error fetching comments:", error);
        commentsContainer.innerHTML = "<p>Error loading comments.</p>";
      }
    }
    
    // Function to create a comment element
    function createCommentElement(comment, isReply = false) {
      const commentDiv = document.createElement('div');
      commentDiv.className = isReply ? 'comment reply-comment' : 'comment';
      commentDiv.id = `comment-${comment.id}`;
      commentDiv.dataset.parentId = comment.parentId || '';

      // Determine the avatar to display
      let avatarHTML = '';
      if (comment.avatarUrl) {
        if (comment.avatarUrl.startsWith('http')) {
          // If it's a full URL, use it directly
          avatarHTML = `<img src="${comment.avatarUrl}" alt="${comment.name}'s avatar" class="comment-avatar">`;
        } else if (comment.avatarUrl.match(/avatar([1-9]|1[0-2])\.png/) || comment.avatarUrl.match(/avatar([1-9]|1[0-2])\.jpg/)) {
          // It's one of our avatar images
          avatarHTML = `<img src="images/avatar-icons/${comment.avatarUrl}" alt="${comment.name}'s avatar" class="comment-avatar">`;
        } else {
          // Fallback to placeholder
          avatarHTML = `<img src="https://ui-avatars.com/api/?name=${comment.name.charAt(0)}&background=random&color=fff&size=128" alt="${comment.name}'s avatar" class="comment-avatar">`;
        }
      } else {
        // Use default avatar if no avatar is set
        avatarHTML = `<img src="https://ui-avatars.com/api/?name=${comment.name.charAt(0)}&background=random&color=fff&size=128" alt="${comment.name}'s avatar" class="comment-avatar">`;
      }

      // Format the date
      const date = comment.createdAt ? new Date(comment.createdAt.seconds * 1000) : new Date();
      const now = new Date();
      const diffInMilliseconds = now - date;
      const diffInSeconds = Math.floor(diffInMilliseconds / 1000);
      const diffInMinutes = Math.floor(diffInSeconds / 60);
      const diffInHours = Math.floor(diffInMinutes / 60);
      const diffInDays = Math.floor(diffInHours / 24);
      let dateText;

      if (diffInDays > 30) {
        dateText = `${date.toLocaleDateString()}`;
      } else if (diffInDays > 0) {
        dateText = `${diffInDays} day${diffInDays > 1 ? 's' : ''} ago`;
      } else if (diffInHours > 0) {
        dateText = `${diffInHours} hour${diffInHours > 1 ? 's' : ''} ago`;
      } else if (diffInMinutes > 0) {
        dateText = `${diffInMinutes} minute${diffInMinutes > 1 ? 's' : ''} ago`;
      } else {
        dateText = 'Just now';
      }

      // Build the comment HTML with or without reply option based on if this is already a reply
      const actionsHtml = isReply ? 
        `<div class="comment-actions"></div>` : 
        `<div class="comment-actions">
          <a href="#" class="comment-action reply-action" data-comment-id="${comment.id}">Reply</a>
        </div>
        <div class="reply-form" id="replyForm-${comment.id}">
          <textarea placeholder="Write your reply..." id="replyText-${comment.id}"></textarea>
          <div class="reply-actions">
            <button class="reply-cancel" data-comment-id="${comment.id}">Cancel</button>
            <button class="reply-submit" data-comment-id="${comment.id}">Reply</button>
          </div>
        </div>`;

      commentDiv.innerHTML = `
        <div class="comment-header">
          <div class="comment-avatar-container">
            <div class="comment-avatar">${avatarHTML}</div>
          </div>
          <div class="comment-info">
            <div class="comment-author">${comment.name}</div>
            <div class="comment-date">${dateText}</div>
          </div>
        </div>
        <div class="comment-content">${comment.text}</div>
        ${actionsHtml}
      `;
      
      // Only add reply event listeners if this is not already a reply
      if (!isReply) {
        const replyAction = commentDiv.querySelector('.reply-action');
        if (replyAction) {
          replyAction.addEventListener('click', (e) => {
            e.preventDefault();
            toggleReplyForm(comment.id);
          });
          
          const cancelButton = commentDiv.querySelector('.reply-cancel');
          if (cancelButton) {
            cancelButton.addEventListener('click', () => {
              toggleReplyForm(comment.id, false);
            });
          }
          
          const submitButton = commentDiv.querySelector('.reply-submit');
          if (submitButton) {
            submitButton.addEventListener('click', () => {
              submitReply(comment.id);
            });
          }
        }
      }
      
      return commentDiv;
    }
    
    // Toggle reply form visibility
    function toggleReplyForm(commentId, show) {
      const replyForm = document.getElementById(`replyForm-${commentId}`);
      if (!replyForm) return;
      
      if (show === undefined) {
        // Toggle visibility if not specified
        replyForm.classList.toggle('visible');
      } else if (show) {
        replyForm.classList.add('visible');
      } else {
        replyForm.classList.remove('visible');
      }
      
      // If showing the form, focus the textarea
      if (replyForm.classList.contains('visible')) {
        document.getElementById(`replyText-${commentId}`).focus();
      }
    }
    
    // Submit a reply to a comment
    async function submitReply(parentId) {
      // Check if user is logged in first
      if (!auth.currentUser) {
        alert('Please log in to reply to comments');
        return;
      }
      
      const replyTextArea = document.getElementById(`replyText-${parentId}`);
      const replyText = replyTextArea.value.trim();
      
      if (!replyText) {
        alert('Please enter a reply');
        return;
      }
      
      try {
        // Get the post ID from the URL
        const urlParams = new URLSearchParams(window.location.search);
        const postId = urlParams.get("postId");
        
        if (!postId) {
          alert('Error: Cannot identify the post');
          return;
        }
        
        // Get the parent comment element to verify it's not already a reply
        const parentComment = document.getElementById(`comment-${parentId}`);
        if (!parentComment) {
          alert('Error: Cannot find the parent comment');
          return;
        }
        
        // Stop if trying to reply to a reply (double check at the UI level)
        if (parentComment.classList.contains('reply-comment') || 
            parentComment.classList.contains('orphaned-reply') ||
            parentComment.dataset.parentId) {
          alert('Replies to replies are not allowed. Please reply to the original comment.');
          return;
        }
        
        // Additionally check at the data level
        const parentCommentRef = collection(doc(db, "posts", postId), "comments");
        const parentDocRef = doc(parentCommentRef, parentId);
        const parentDocSnap = await getDoc(parentDocRef);
        
        if (parentDocSnap.exists() && parentDocSnap.data().parentId) {
          alert('Replies to replies are not allowed. Please reply to the original comment.');
          return;
        }
        
        // Get user data from Firestore
        const userRef = doc(db, "users", auth.currentUser.uid);
        const userSnap = await getDoc(userRef);
        
        if (!userSnap.exists()) {
          alert("Could not retrieve your user profile. Please try again.");
          return;
        }
        
        const userData = userSnap.data();
        
        // Reference to subcollection: posts/{postId}/comments
        const commentsRef = collection(doc(db, "posts", postId), "comments");
        
        console.log(`Submitting reply to comment ${parentId}`);
        
        // Add the reply as a new comment with parentId reference
        const replyData = {
          text: replyText,
          name: userData.username || auth.currentUser.displayName || 'User',
          email: auth.currentUser.email,
          avatarUrl: userData.avatarUrl,
          parentId: parentId,  // Store the parent comment ID
          userId: auth.currentUser.uid,
          createdAt: serverTimestamp(),
        };
        
        await addDoc(commentsRef, replyData);
        console.log("Reply added with parentId:", parentId);
        
        // Hide the reply form
        toggleReplyForm(parentId, false);
        
        // Refresh comments
        await fetchAndDisplayComments(postId);
        
        // Clear the textarea
        replyTextArea.value = '';
        
        // Use notification instead of alert for better UX
        const notification = document.createElement('div');
        notification.className = 'notification success';
        notification.textContent = 'Reply submitted successfully!';
        document.body.appendChild(notification);
        
        // Remove the notification after 3 seconds
        setTimeout(() => {
          notification.remove();
        }, 3000);
      } catch (error) {
        console.error('Error submitting reply:', error);
        alert('Error submitting reply. Please try again.');
      }
    }

    // 4. Load recent posts in the sidebar
    async function loadRecentPosts() {
      const recentPostsList = document.getElementById("recentPostsList");
      if (!recentPostsList) return;

      try {
        const q = query(collection(db, "posts"), orderBy("createdAt", "desc"));
        const querySnapshot = await getDocs(q);
        
        // Clear existing posts
        recentPostsList.innerHTML = "";
        
        // Add the first 3 posts
        querySnapshot.docs.slice(0, 3).forEach(doc => {
          const post = doc.data();
          const recentPostElement = document.createElement("a");
          recentPostElement.href = `post.html?postId=${doc.id}`;
          recentPostElement.className = "recent-post-item";
          
          // Create thumbnail image or placeholder
          const imageHtml = post.imageUrl 
            ? `<img src="${post.imageUrl}" alt="${post.title}">`
            : `<div style="width: 60px; height: 60px; background-color: #f0f0f0; border-radius: 8px;"></div>`;
          
          recentPostElement.innerHTML = `
            ${imageHtml}
            <div class="post-title">${post.title}</div>
          `;
          
          recentPostsList.appendChild(recentPostElement);
        });
      } catch (error) {
        console.error("Error loading recent posts:", error);
        recentPostsList.innerHTML = "<p>Error loading recent posts.</p>";
      }
    }
  </script>

  <!-- JavaScript for Admin Dropdown Menu -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Simple dropdown toggle for admin menu
        const adminBtn = document.getElementById('adminDropdownBtn');
        if (adminBtn) {
            // For both click and touch events
            ['click', 'touchend'].forEach(eventType => {
                adminBtn.addEventListener(eventType, function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const dropdownContent = document.getElementById('adminDropdownContent');
                    if (dropdownContent) {
                        // Direct style manipulation for more reliable display
                        if (dropdownContent.style.display === 'block') {
                            dropdownContent.style.display = 'none';
                        } else {
                            // Position dropdown based on screen size
                            if (window.innerWidth <= 480) {
                                // Mobile positioning - calculate position but use fixed
                                const btnRect = adminBtn.getBoundingClientRect();
                                dropdownContent.style.position = 'fixed';
                                dropdownContent.style.top = btnRect.bottom + 'px';
                                dropdownContent.style.left = btnRect.left + 'px';
                                dropdownContent.style.transform = 'none';
                                // Force a recalculation to ensure visibility
                                setTimeout(() => {
                                    dropdownContent.style.display = 'block';
                                }, 0);
                            } else {
                                // Desktop positioning - under button
                                dropdownContent.style.position = 'absolute';
                                dropdownContent.style.left = '0';
                                dropdownContent.style.top = '100%';
                                dropdownContent.style.transform = 'none';
                                dropdownContent.style.display = 'block';
                            }
                        }
                    }
                });
            });
            
            // Close dropdown when clicking or touching elsewhere
            ['click', 'touchend'].forEach(eventType => {
                document.addEventListener(eventType, function(event) {
                    const dropdownContent = document.getElementById('adminDropdownContent');
                    if (dropdownContent && event.target !== adminBtn && !adminBtn.contains(event.target) && !dropdownContent.contains(event.target)) {
                        dropdownContent.style.display = 'none';
                    }
                });
            });
            
            // Fix for mobile menu tap delays on dropdown links
            const dropdownLinks = document.querySelectorAll('.admin-dropdown-content a');
            dropdownLinks.forEach(link => {
                link.addEventListener('touchstart', function(e) {
                    // Prevent double-firing of events
                    e.stopPropagation();
                });
                
                link.addEventListener('touchend', function(e) {
                    // Navigate to the link href directly
                    if (this.href) {
                        window.location.href = this.href;
                    }
                });
            });
        }
    });
  </script>
</body>
</html>