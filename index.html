<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no, viewport-fit=cover">
  <title>Makeup Blog - Homepage</title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <!-- Google Fonts for Cursive Options -->
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script&family=Great+Vibes&family=Pacifico&family=Satisfy&family=Allura&family=Tangerine&family=Pinyon+Script&family=Alex+Brush&display=swap" rel="stylesheet">
  <style>
    /* Basic layout styles */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f9f9f9;
      color: #333;
      line-height: 1.6;
      overflow-x: hidden; /* Prevent horizontal scrolling */
      width: 100%;
      max-width: 100vw;
      box-sizing: border-box;
    }

    * {
      box-sizing: border-box;
      max-width: 100%;
    }

    /* Content visibility control */
    .content-loader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #f9f9f9;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      transition: opacity 0.5s ease, visibility 0.5s ease;
    }

    .content-loader.hidden {
      opacity: 0;
      visibility: hidden;
    }

    .loader-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid #f3f3f3;
      border-top: 5px solid #a07;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Hide editable content until loaded */
    .editable-container {
      visibility: hidden;
      opacity: 0;
      transition: visibility 0.3s ease, opacity 0.3s ease;
    }

    .editable-container.loaded {
      visibility: visible;
      opacity: 1;
    }

    /* Edit mode button styles */
    #edit-mode-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      background-color: #fff;
      border-radius: 50%;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      z-index: 9999;
      transition: transform 0.3s ease, background-color 0.3s ease;
    }

    #edit-mode-toggle:hover {
      transform: scale(1.1);
    }

    #edit-mode-toggle.active {
      background-color: #ff69b4;
      color: white;
    }

    /* Editable content styles */
    .editable {
      transition: outline 0.3s ease, background-color 0.3s ease;
    }

    .editable.edit-mode {
      outline: 2px solid #ff69b4;
      outline-offset: 2px;
      background-color: rgba(255, 105, 180, 0.05);
    }

    /* Save Status Indicator */
    #save-status {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 8px 16px;
      border-radius: 4px;
      font-size: 14px;
      font-weight: bold;
      z-index: 9999;
      opacity: 0;
      transition: opacity 0.3s ease;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    #save-status.show {
      opacity: 1;
    }

    #save-status.success {
      background-color: #4CAF50;
      color: white;
    }

    #save-status.error {
      background-color: #F44336;
      color: white;
    }

    #save-status.saving {
      background-color: #FFC107;
      color: black;
    }

    /* White box mimicking the dropdown */
    .black-box {
      position: fixed;
      background-color: white;
      z-index: 999;
      display: none; /* Hidden by default */
      width: auto;
      height: auto;
      min-width: 180px; /* Match dropdown width */
      box-shadow: 0 8px 16px rgba(0,0,0,0.1);
      border-radius: 4px;
      overflow: hidden;
      border: 1px solid #eee;
    }
    
    /* Menu items in the white box */
    .black-box a {
      color: #333;
      padding: 12px 16px;
      text-decoration: none;
      display: block;
      text-align: left;
      transition: background-color 0.2s, color 0.2s;
      border-bottom: 1px solid #f5f5f5;
    }
    
    .black-box a:last-child {
      border-bottom: none;
    }
    
    .black-box a:hover {
      background-color: #f9f9f9;
      color: #a07;
    }

    /* Admin Dropdown Menu Styles */
    .admin-dropdown {
      position: relative;
      display: inline-block;
      z-index: 1000; /* Ensure dropdown appears in front of other elements */
    }

    .admin-dropdown-btn {
      background: none;
      border: none;
      color: #333;
      font-size: 1em;
      padding: 10px;
      cursor: pointer;
      font-family: inherit;
      text-decoration: none;
      display: none;
      transition: color 0.2s;
      display: flex;
      align-items: center;
      position: relative;
      bottom: -8px; /* Lower the Admin Dashboard text to match other items */
      z-index: 1000; /* Ensure button appears in front */
    }

    .admin-dropdown-btn .dropdown-icon {
      display: inline-block;
      margin-left: 5px;
      transition: transform 0.3s ease;
    }

    .admin-dropdown-btn.active .dropdown-icon {
      transform: rotate(180deg);
    }

    .admin-dropdown-btn:hover, 
    .admin-dropdown-btn.active {
      color: #a07;
    }

    /* Desktop position for admin dashboard text */
    @media (min-width: 768px) {
      .admin-dropdown-btn {
        bottom: 0px; /* Move text higher up for desktop view */
      }
    }

    /* Responsive adjustments for admin dropdown */
    @media (max-width: 768px) {
      .admin-dropdown-content {
        position: absolute;
        right: 0;
        left: auto;
        width: 200px;
        z-index: 2000; /* Much higher z-index for mobile */
        box-shadow: 0 8px 16px rgba(0,0,0,0.2);
      }

      .admin-dropdown {
        position: relative;
        z-index: 1500;
      }

      header nav {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        position: relative;
        z-index: auto; /* Reset any z-index that might be interfering */
      }
      
      /* Ensure the dropdown shows on top of everything when active */
      .show-dropdown {
        display: block !important;
        opacity: 1 !important;
        transform: translateY(0) !important;
        z-index: 9999 !important; /* Extremely high z-index */
      }
    }

    /* For very small screens */
    @media (max-width: 480px) {
      .admin-dropdown-content {
        right: -50px; /* Adjust position to be more centered on small screens */
      }

      .admin-dropdown-btn {
        padding: 10px 5px;
        bottom: 2px; /* Raise the Admin Dashboard text on mobile */
      }
    }

    /* Avatar Popup Styles */
    .avatar-popup {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      overflow: hidden;
    }

    .avatar-popup-content {
      background-color: #fff;
      margin: 10% auto;
      padding: 20px;
      border-radius: 8px;
      width: 350px;
      max-width: 90%;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      text-align: center;
    }

    .avatar-popup h3 {
      margin-top: 0;
      margin-bottom: 10px;
      color: #333;
      font-size: 1.3em;
    }
    
    .avatar-popup p {
      margin-bottom: 15px;
      font-size: 0.9em;
    }

    .avatar-popup button {
      margin-top: 15px;
      padding: 10px 20px;
      background-color: #333;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      width: 150px;
    }

    .avatar-popup button:hover {
      background-color: #555;
    }
    
    .avatar-popup button:disabled {
      background-color: #999;
      cursor: not-allowed;
    }
    
    #closeAvatarPopup {
      background-color: #666;
    }
    
    .avatar-options {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      margin: 15px 0;
    }
    
    .avatar-option {
      border: 2px solid #ddd;
      border-radius: 8px;
      padding: 3px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .avatar-option:hover {
      border-color: #999;
      transform: scale(1.05);
    }
    
    .avatar-option.selected {
      border-color: #333;
      background-color: #f0f0f0;
    }
    
    .avatar-option img {
      width: 100%;
      height: auto;
      border-radius: 50%;
    }
    
    .selected-avatar-container {
      margin: 10px 0;
      font-weight: bold;
    }

    /* Custom font styles for blog posts */
    #blogPosts h3[style*="font-family: 'Dancing Script'"],
    #blogPosts h3[style*="font-family: Dancing Script"] {
      font-family: 'Dancing Script', cursive !important;
    }
    
    #blogPosts h3[style*="font-family: 'Great Vibes'"],
    #blogPosts h3[style*="font-family: Great Vibes"] {
      font-family: 'Great Vibes', cursive !important;
    }
    
    #blogPosts h3[style*="font-family: 'Pacifico'"],
    #blogPosts h3[style*="font-family: Pacifico"] {
      font-family: 'Pacifico', cursive !important;
    }
    
    #blogPosts h3[style*="font-family: 'Satisfy'"],
    #blogPosts h3[style*="font-family: Satisfy"] {
      font-family: 'Satisfy', cursive !important;
    }
    
    #blogPosts h3[style*="font-family: 'Allura'"],
    #blogPosts h3[style*="font-family: Allura"] {
      font-family: 'Allura', cursive !important;
    }
    
    #blogPosts h3[style*="font-family: 'Brush Script MT'"],
    #blogPosts h3[style*="font-family: Brush Script MT"] {
      font-family: 'Brush Script MT', cursive !important;
    }
    
    #blogPosts h3[style*="font-family: 'Tangerine'"],
    #blogPosts h3[style*="font-family: Tangerine"] {
      font-family: 'Tangerine', cursive !important;
    }
    
    #blogPosts h3[style*="font-family: 'Alex Brush'"],
    #blogPosts h3[style*="font-family: Alex Brush"] {
      font-family: 'Alex Brush', cursive !important;
    }
    
    #blogPosts h3[style*="font-family: 'Pinyon Script'"],
    #blogPosts h3[style*="font-family: Pinyon Script"] {
      font-family: 'Pinyon Script', cursive !important;
    }
    
    #blogPosts h3[style*="font-family: 'Monsieur La Doulaise'"],
    #blogPosts h3[style*="font-family: Monsieur La Doulaise"] {
      font-family: 'Monsieur La Doulaise', cursive !important;
    }

    /* Additional styles for post titles */
    #blogPosts h3 {
      margin-bottom: 15px;
      font-size: 1.8em;
      line-height: 1.3;
    }

    .sorting-options {
      width: 100%;
      max-width: 800px;
      margin: 0 0 20px;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid #eee;
    }

    .sorting-options span {
      margin-right: 10px;
      color: #555;
      font-size: 0.9em;
    }

    .sorting-options select {
      padding: 6px 10px;
      border-radius: 4px;
      border: 1px solid #ddd;
      background-color: white;
      cursor: pointer;
      font-size: 0.9em;
      color: #333;
      outline: none;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .sorting-options select:hover {
      border-color: #bbb;
    }

    .sorting-options select:focus {
      border-color: #a07;
      box-shadow: 0 0 0 2px rgba(170, 0, 119, 0.1);
    }

    /* Active sort indicator */
    .active-sort {
      display: none;
      margin-left: 15px;
      font-size: 0.85em;
      color: #a07;
      font-weight: bold;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .sorting-options {
        justify-content: center;
        margin-bottom: 15px;
      }
      
      #blogPosts > div {
        padding: 0 10px;
      }
      
      #blogPosts h3 {
        font-size: 1.5em;
      }

      #blogPosts img {
        max-width: 100%;
        height: auto;
      }

      /* Adjust post content for mobile */
      #blogPosts p {
        font-size: 0.95em;
      }
    }

    /* For very small screens */
    @media (max-width: 480px) {
      /* Ensure content fits perfectly */
      .content {
        padding: 0;
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
        overflow: hidden;
      }
      
      /* Position posts on left */
      .posts {
        margin: 0;
        padding: 5px;
        align-self: flex-start;
      }
      
      /* Position about-me on right edge */
      .about-me {
        margin: 0;
        padding: 5px;
        align-self: flex-end;
      }

      /* Center social media icons on mobile */
      .social-links .social-icons {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
      }
      
      .social-links h3 {
        text-align: center;
      }
      
      header img {
        max-width: 100%;
        height: auto;
      }

      #blogPosts h3 {
        font-size: 1.2em;
      }

      #blogPosts p {
        font-size: 0.9em;
      }

      /* Adjust images for smaller screens */
      #blogPosts img,
      .recent-post-item img {
        max-width: 100%;
        height: auto;
      }
    }

    .posts {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
    }
    
    #blogPosts {
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
    }
    
    #blogPosts > div {
      text-align: center;
      margin-bottom: 30px;
    }
    
    #blogPosts img {
      max-width: 100%;
      height: auto;
      margin: 15px 0;
      border-radius: 8px;
    }
    
    #blogPosts p {
      text-align: left;
      line-height: 1.6;
    }

    .recent-post-item {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      padding: 10px 0;
      text-decoration: none;
      color: inherit;
      border-bottom: 1px solid #eee;
    }

    .recent-post-item:last-child {
      border-bottom: none;
    }

    .recent-post-item img {
      width: 60px;
      height: 60px;
      object-fit: cover;
      border-radius: 4px;
      flex-shrink: 0;
    }

    .post-title {
      font-size: 0.9em;
      line-height: 1.4;
      margin-bottom: 3px;
    }

    .read-more-btn {
      display: inline-block;
      padding: 8px 16px;
      background: transparent;
      border: 2px solid #222;
      color: #222;
      font-size: 14px;
      font-weight: bold;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      margin-top: 10px;
    }
    
    .read-more-btn:hover {
      background: #222;
      color: white;
    }

    /* Make sure no extra lines appear between meta and content */
    .post-meta {
      border-bottom: none !important;
      padding-bottom: 0 !important;
      margin-bottom: 15px !important;
    }
    
    .post-meta + * {
      border-top: none !important;
      padding-top: 0 !important;
      margin-top: 0 !important;
    }
    
    /* Settings gear icon styles */
    .settings-icon {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: rgba(255, 255, 255, 0.8);
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      z-index: 100;
      transition: transform 0.3s ease;
      cursor: pointer;
    }

    .settings-icon:hover {
      transform: rotate(30deg);
    }

    .settings-icon svg {
      width: 22px;
      height: 22px;
      fill: #333;
    }

    /* Contact dropdown styles */
    .contact-dropdown-btn:hover, 
    .contact-dropdown-btn.active {
      color: #a07 !important;
    }

    .contact-dropdown-btn .dropdown-icon {
      transition: transform 0.3s ease;
    }

    .contact-dropdown-btn.active .dropdown-icon {
      transform: rotate(180deg);
    }
  </style>
</head>
<body>

  <!-- Loading spinner overlay -->
  <div id="contentLoader" class="content-loader">
    <div class="loader-spinner"></div>
  </div>

  <!-- Header Section -->
  <header>
    <a href="index.html">
      <img src="nbvlogo.png" alt="Ny's Beauty Vault Logo" style="width: 100%; max-width: 610px; height: auto; object-fit: contain;">
    </a>
    <nav id="mainNav">
      <a href="index.html" class="active">Home</a>
      <a href="about.html">About</a>
      <!-- Convert Contact to a dropdown -->
      <div class="contact-dropdown" style="display: inline-block; position: relative;">
        <a id="contactDropdownBtn" class="contact-dropdown-btn" href="#" style="color: #333; text-decoration: none; display: flex; align-items: center;">
          Contact 
          <span class="dropdown-icon" style="display: inline-block; margin-left: 5px;">▼</span>
        </a>
      </div>
      <!-- Admin dropdown menu (initially hidden) -->
      <div class="admin-dropdown">
        <a id="adminDropdownBtn" class="admin-dropdown-btn" href="#" style="display:none;">
          Admin Dashboard 
          <span class="dropdown-icon">▼</span>
        </a>
      </div>
      <!-- User account link -->
      <a id="userAccountLink" href="settings.html" style="display:none;">My Account</a>
      <!-- Public links -->
      <a id="login-link" href="login.html">Login</a>
      <button id="logout-btn" style="display:none;">Logout</button>
    </nav>
  </header>

  <!-- Settings Icon -->
  <a href="settings.html" class="settings-icon" id="settingsIcon" style="display:none;" title="Account Settings">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
      <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
    </svg>
  </a>

  <!-- Edit Mode Button (Admin only) -->
  <div id="edit-mode-toggle" style="display:none; top: 70px;">
    <i class="fas fa-pencil-alt"></i>
  </div>

  <!-- Save Status Indicator -->
  <div id="save-status">Saving changes...</div>

  <!-- Black box in the middle of the page (admin dropdown content) -->
  <div class="black-box">
    <a href="admin-dashboard.html">Messages</a>
    <a href="editor.html">Create Post</a>
    <a href="edit-post.html">Edit Posts</a>
    <a href="manage-users.html">User Management</a>
  </div>

  <!-- Contact dropdown black box -->
  <div class="contact-black-box" style="position: fixed; background-color: white; z-index: 999; display: none; width: auto; height: auto; min-width: 50px !important; box-shadow: 0 8px 16px rgba(0,0,0,0.1); border-radius: 4px; overflow: hidden; border: 1px solid #eee;">
    <a href="contact.html" style="color: #333; padding: 12px 16px; text-decoration: none; display: block; text-align: left; transition: background-color 0.2s, color 0.2s; border-bottom: 1px solid #f5f5f5;">Contact</a>
    <a href="https://glammedbyglizz.youcanbook.me/" target="_blank" style="color: #333; padding: 12px 16px; text-decoration: none; display: block; text-align: left; transition: background-color 0.2s, color 0.2s;">Booking</a>
  </div>

  <!-- Main Content Area -->
  <div class="content">
    <!-- Posts Section -->
    <main class="posts">
      <!-- Container where posts will be loaded -->
      <div id="blogPosts"></div>
    </main>

    <!-- About Me Sidebar -->
    <aside class="about-me">
      <img src="nyredhair.jpg" alt="Ny Red Hair" class="profile-pic">

      <div class="editable-container">
        <p class="editable">
          Hello and welcome to my Makeup and Beauty Blog! I'm Ny, an aspiring makeup artist who's absolutely head-over-heels for all things beauty.
        </p>
        <p class="editable">
          Dive into honest product rundowns, foolproof tutorials, and the latest beauty buzz—like a monthly magazine come to life, but with my personal spin (and the occasional cameo from my family). Enjoy!
        </p>
      </div>

      <!-- Social Media Links -->
      <div class="social-links">
        <h3 style="font-size: 1.1em; margin: 20px 0 10px;" class="editable">Follow Me</h3>
        <div class="social-icons">
          <a href="https://www.instagram.com/_ryymone?igsh=N2M5azhzZ3h3ZzJl" class="social-icon instagram"><i class="fab fa-instagram"></i> Instagram</a>
          <a href="https://www.facebook.com/nyisha.rymone.1?mibextid=wwXIfr&rdid=AnupCw1sMQ1JiIU2&share_url=https%3A%2F%2Fwww.facebook.com%2Fshare%2F1AGiUj9TMu%2F%3Fmibextid%3DwwXIfr" class="social-icon facebook"><i class="fab fa-facebook-f"></i> Facebook</a>
        </div>
      </div>

      <!-- Sorting Options (moved below Follow Me) -->
      <div class="sorting-options" style="border-bottom: none; justify-content: flex-start; margin: 15px 0 5px; padding: 0;">
        <span style="font-size: 0.9em; color: #555;">Sort posts by:</span>
        <select id="sortPosts" style="font-size: 0.8em; padding: 4px 8px;">
          <option value="newest">Newest</option>
          <option value="oldest">Oldest</option>
          <option value="comments">Most Comments</option>
        </select>
        <span id="activeSortIndicator" class="active-sort">Newest</span>
      </div>

      <!-- Recent Posts -->
      <div class="recent-posts">
        <h3 style="font-size: 1.1em; margin: 20px 0 10px;">Recent Posts</h3>
        <div id="recentPostsList"></div>
      </div>

      <!-- Search Bar (moved to bottom) -->
      <div class="search-container">
        <input type="text" placeholder="Search posts..." id="searchInput">
      </div>
    </aside>
  </div>

  <!-- Footer Section -->
  <footer>
    <div class="editable-container">
      <p class="editable">&copy; 2025 Makeup by NY</p>
    </div>
  </footer>

  <!-- Avatar selection popup (hidden by default) -->
  <div id="avatarPopup" class="avatar-popup">
    <div class="avatar-popup-content">
      <h3>Choose Your Avatar</h3>
      <p>Please select an avatar to personalize your account</p>
      
      <div class="avatar-options">
        <div class="avatar-option" data-avatar="avatar1.jpg">
          <img src="images/avatar-icons/avatar1.jpg" alt="Avatar 1">
        </div>
        <div class="avatar-option" data-avatar="avatar2.jpg">
          <img src="images/avatar-icons/avatar2.jpg" alt="Avatar 2">
        </div>
        <div class="avatar-option" data-avatar="avatar3.jpg">
          <img src="images/avatar-icons/avatar3.jpg" alt="Avatar 3">
        </div>
        <div class="avatar-option" data-avatar="avatar4.jpg">
          <img src="images/avatar-icons/avatar4.jpg" alt="Avatar 4">
        </div>
        <div class="avatar-option" data-avatar="avatar5.jpg">
          <img src="images/avatar-icons/avatar5.jpg" alt="Avatar 5">
        </div>
        <div class="avatar-option" data-avatar="avatar6.jpg">
          <img src="images/avatar-icons/avatar6.jpg" alt="Avatar 6">
        </div>
        <div class="avatar-option" data-avatar="avatar7.jpg">
          <img src="images/avatar-icons/avatar7.jpg" alt="Avatar 7">
        </div>
        <div class="avatar-option" data-avatar="avatar8.jpg">
          <img src="images/avatar-icons/avatar8.jpg" alt="Avatar 8">
        </div>
        <div class="avatar-option" data-avatar="avatar9.jpg">
          <img src="images/avatar-icons/avatar9.jpg" alt="Avatar 9">
        </div>
        <div class="avatar-option" data-avatar="avatar10.jpg">
          <img src="images/avatar-icons/avatar10.jpg" alt="Avatar 10">
        </div>
        <div class="avatar-option" data-avatar="avatar11.jpg">
          <img src="images/avatar-icons/avatar11.jpg" alt="Avatar 11">
        </div>
        <div class="avatar-option" data-avatar="avatar12.jpg">
          <img src="images/avatar-icons/avatar12.jpg" alt="Avatar 12">
        </div>
      </div>
      
      <button id="saveAvatarBtn" disabled>Save Selection</button>
    </div>
  </div>

  <!-- Load firebase.js first to initialize Firebase -->
  <script type="module" src="firebase.js"></script>

  <!-- Main JavaScript for handling posts, authentication, and UI -->
  <script type="module">
    // Import necessary Firebase modules
    import { db, isAdminUser } from "./firebase-config.js";  // Import Firestore database instance
    import { collection, getDocs, query, orderBy, doc, getDoc, updateDoc } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js";  // Firestore functions
    import { onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-auth.js";  // Auth state observer
    import { auth } from "./firebase-config.js";  // Auth instance

    // Initialize the page when DOM is loaded
    document.addEventListener("DOMContentLoaded", () => {
      // Monitor user authentication state
      onAuthStateChanged(auth, async (user) => {
        // If user is logged in
        if (user) {
          // Hide login button, show logout button and account link
          document.getElementById("login-link").style.display = "none";
          document.getElementById("logout-btn").style.display = "inline";
          document.getElementById("userAccountLink").style.display = "inline";
          
          // Show settings icon for logged in users
          document.getElementById("settingsIcon").style.display = "flex";

          // Only show avatar popup for new users - check in Firestore
          try {
            // Check user's profile in Firestore to see if they've selected an avatar
            const userRef = doc(db, "users", user.uid);
            const userDoc = await getDoc(userRef);
            
            if (userDoc.exists()) {
              const userData = userDoc.data();
              
              // If user doesn't have hasSelectedAvatar flag or it's false
              if (!userData.hasSelectedAvatar) {
                // Show avatar popup after a slight delay to ensure page is loaded first
                setTimeout(() => {
                  const avatarPopup = document.getElementById("avatarPopup");
                  avatarPopup.style.display = "block";
                  
                  // Disable scrolling on the body when popup is shown
                  document.body.style.overflow = "hidden";
                  
                  // Track which avatar is selected
                  let selectedAvatar = null;
                  const saveButton = document.getElementById("saveAvatarBtn");
                  
                  // Prevent closing the popup with Escape key
                  window.addEventListener("keydown", function(e) {
                    if (e.key === "Escape" && avatarPopup.style.display === "block") {
                      e.preventDefault();
                      e.stopPropagation();
                    }
                  });
                  
                  // Prevent closing by clicking outside
                  window.addEventListener("click", function(e) {
                    if (e.target === avatarPopup) {
                      e.preventDefault();
                      e.stopPropagation();
                    }
                  });
                  
                  // Add click event handlers to all avatar options
                  const avatarOptions = document.querySelectorAll(".avatar-option");
                  avatarOptions.forEach(option => {
                    option.addEventListener("click", () => {
                      // Remove selected class from all options
                      avatarOptions.forEach(opt => opt.classList.remove("selected"));
                      
                      // Add selected class to clicked option
                      option.classList.add("selected");
                      
                      // Store the selected avatar
                      selectedAvatar = option.getAttribute("data-avatar");
                      
                      // Enable the save button
                      saveButton.disabled = false;
                    });
                  });
                  
                  // Handle save button click
                  saveButton.addEventListener("click", async () => {
                    if (selectedAvatar) {
                      // Show loading state
                      saveButton.textContent = "Saving...";
                      saveButton.disabled = true;
                      
                      try {
                        // Update user's profile in Firestore with selected avatar
                        await updateDoc(userRef, {
                          avatarUrl: selectedAvatar,
                          hasSelectedAvatar: true
                        });
                        
                        // Close the popup
                        avatarPopup.style.display = "none";
                        
                        // Re-enable scrolling
                        document.body.style.overflow = "";
                        
                        // Optionally show a success message
                        alert("Avatar selected successfully!");
                        
                        // Reload the page to reflect changes
                        location.reload();
                      } catch (error) {
                        console.error("Error saving avatar selection:", error);
                        alert("There was a problem saving your avatar. Please try again.");
                        
                        // Re-enable the save button
                        saveButton.textContent = "Save Selection";
                        saveButton.disabled = false;
                      }
                    }
                  });
                }, 1500); // 1.5 second delay before showing popup
              }
            }
          } catch (error) {
            console.error("Error checking avatar selection status:", error);
          }

          // Check if user is admin
          try {
            const isAdmin = await isAdminUser(user.uid);
            if (isAdmin) {
              // Show admin dropdown button
              document.getElementById("adminDropdownBtn").style.display = "flex";
              // Show edit mode button for admin users only
              document.getElementById("edit-mode-toggle").style.display = "flex";
            } else {
              // Hide admin dropdown button for regular users
              document.getElementById("adminDropdownBtn").style.display = "none";
              // Hide edit mode button for regular users
              document.getElementById("edit-mode-toggle").style.display = "none";
            }
          } catch (error) {
            console.error("Error checking admin status:", error);
            // Hide admin dropdown button in case of error
            document.getElementById("adminDropdownBtn").style.display = "none";
            // Hide edit mode button in case of error
            document.getElementById("edit-mode-toggle").style.display = "none";
          }
        } else {
          // If user is not logged in, show login button and hide user features
          document.getElementById("login-link").style.display = "inline";
          document.getElementById("logout-btn").style.display = "none";
          document.getElementById("userAccountLink").style.display = "none";
          document.getElementById("adminDropdownBtn").style.display = "none";
          
          // Hide settings icon for anonymous users
          document.getElementById("settingsIcon").style.display = "none";
          
          // Hide edit mode button for non-logged in users
          document.getElementById("edit-mode-toggle").style.display = "none";
        }
      });

      // Handle logout button click
      document.getElementById("logout-btn").addEventListener("click", () => {
        signOut(auth).then(() => {
          window.location.href = "index.html";
        }).catch(error => {
          console.error("Error signing out:", error);
        });
      });

      // Get container for blog posts
      const blogPostsContainer = document.getElementById("blogPosts");
      let allPosts = []; // Store all posts for sorting

      // Function to render posts based on current sort order
      const renderPosts = (posts) => {
        // Clear the container
        blogPostsContainer.innerHTML = '';

        // Display all posts in the main content area
        for (let i = 0; i < posts.length; i++) {
          const post = posts[i];
          // Get comment count for each post
          post.commentCount = post.commentCount || 0; // Use cached count if available

          // Create post image HTML if available
          const imageHtml = post.imageUrl 
            ? `<img src="${post.imageUrl}" alt="${post.title} image" style="max-width:100%; height:auto;">`
            : "";

          // Create content preview (strip HTML and limit to 200 characters)
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = post.content;
          const textContent = tempDiv.textContent || tempDiv.innerText || '';
          const contentPreview = textContent.length > 200 
            ? textContent.substring(0, 200) + '...' 
            : textContent;

          // Create and append post element
          const postElement = document.createElement("div");
          
          // Get date for display (use postDate if available, fallback to createdAt)
          const getPostDate = (post) => {
            if (post.postDate) {
              // If postDate exists, it could be a string or a timestamp
              return typeof post.postDate === 'string' 
                ? new Date(post.postDate) 
                : new Date(post.postDate);
            } else {
              // Fall back to createdAt, which is a Firestore timestamp
              return post.createdAt.toDate();
            }
          };
          
          const displayDate = getPostDate(post);

          postElement.innerHTML = `
            <a href="post.html?postId=${post.id}" style="text-decoration: none; color: inherit;">
              <h3 style="${post.titleFont ? `font-family: '${post.titleFont}', cursive` : ''}">${post.title}</h3>
              <hr style="width: 30%; margin: 10px auto; border-top: 1px solid #000; border-bottom: none;">
              <div class="post-meta" style="font-size: 0.9em; margin-bottom: 10px;">
                <span style="color: #000;">${displayDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })}</span> <span style="color: #000;">by</span> <span style="color: #df3d85;">Ny</span> <span style="color: #000;">-</span> <a href="post.html?postId=${post.id}#comments" style="color: #df3d85; text-decoration: none;"><span style="color: #df3d85;">${post.commentCount} comment${post.commentCount !== 1 ? 's' : ''}</span></a>
              </div>
              ${imageHtml}
              <p>${contentPreview}</p>
            </a>
            <div style="text-align: right;">
              <a href="post.html?postId=${post.id}" class="read-more-btn">Read More <span style="display: inline-block; margin-left: 5px;">▶</span></a>
            </div>
          `;
          blogPostsContainer.appendChild(postElement);
          
          // Add a bottom border to separate posts (except the last one)
          if (i < posts.length - 1) {
            postElement.style.borderBottom = "1px solid #000";
            postElement.style.paddingBottom = "30px";
            postElement.style.marginBottom = "30px";
          }
        }
      };

      // Function to sort posts based on selected option
      const sortPosts = (sortOption) => {
        let sortedPosts = [...allPosts]; // Create a copy of the posts array
        
        // Helper function to get comparable date from a post
        const getPostDate = (post) => {
          if (post.postDate) {
            // If postDate exists, it could be a string or a timestamp
            return typeof post.postDate === 'string' 
              ? new Date(post.postDate) 
              : new Date(post.postDate);
          } else {
            // Fall back to createdAt, which is a Firestore timestamp
            return post.createdAt.toDate();
          }
        };
        
        switch(sortOption) {
          case 'newest':
            sortedPosts.sort((a, b) => {
              return getPostDate(b) - getPostDate(a); // Newest first
            });
            break;
          case 'oldest':
            sortedPosts.sort((a, b) => {
              return getPostDate(a) - getPostDate(b); // Oldest first
            });
            break;
          case 'comments':
            sortedPosts.sort((a, b) => b.commentCount - a.commentCount); // Most comments first
            break;
        }
        
        renderPosts(sortedPosts);
      };

      // Add event listener to sort dropdown
      document.getElementById('sortPosts').addEventListener('change', (e) => {
        sortPosts(e.target.value);
        
        // Update the visual indicator
        const indicator = document.getElementById('activeSortIndicator');
        indicator.style.display = 'inline';
        
        // Set the indicator text based on selected option
        switch(e.target.value) {
          case 'newest':
            indicator.textContent = 'Newest';
            break;
          case 'oldest':
            indicator.textContent = 'Oldest';
            break;
          case 'comments':
            indicator.textContent = 'Most Comments';
            break;
        }
      });
      
      // Async function to fetch and display posts
      (async () => {
        try {
          // Query posts collection, ordered by creation date (newest first)
          const q = query(collection(db, "posts"), orderBy("createdAt", "desc"));
          const querySnapshot = await getDocs(q);
          
          // Store all posts in an array
          allPosts = [];
          querySnapshot.forEach((doc) => {
            allPosts.push({ id: doc.id, ...doc.data() });
          });

          // Populate the recent posts sidebar (first 3 posts)
          const recentPostsList = document.getElementById("recentPostsList");
          
          // Sort posts by date for recent posts display (newest first)
          const sortedForRecent = [...allPosts].sort((a, b) => {
            // Helper function to get comparable date from a post
            const getPostDate = (post) => {
              if (post.postDate) {
                // If postDate exists, it could be a string or a timestamp
                return typeof post.postDate === 'string' 
                  ? new Date(post.postDate) 
                  : new Date(post.postDate);
              } else {
                // Fall back to createdAt, which is a Firestore timestamp
                return post.createdAt.toDate();
              }
            };
            
            return getPostDate(b) - getPostDate(a); // Newest first
          });
          
          sortedForRecent.slice(0, 3).forEach(post => {
            const recentPostElement = document.createElement("a");
            recentPostElement.href = `post.html?postId=${post.id}`;
            recentPostElement.className = "recent-post-item";
            
            // Create thumbnail image or placeholder
            const imageHtml = post.imageUrl 
              ? `<img src="${post.imageUrl}" alt="${post.title}">`
              : `<div style="width: 60px; height: 60px; background-color: #f0f0f0; border-radius: 8px;"></div>`;
            
            // Get date for display
            const getPostDate = (post) => {
              if (post.postDate) {
                // If postDate exists, it could be a string or a timestamp
                return typeof post.postDate === 'string' 
                  ? new Date(post.postDate) 
                  : new Date(post.postDate);
              } else {
                // Fall back to createdAt, which is a Firestore timestamp
                return post.createdAt.toDate();
              }
            };
            
            const displayDate = getPostDate(post);
            
            // Set up recent post item HTML
            recentPostElement.innerHTML = `
              ${imageHtml}
              <div>
                <div class="post-title">${post.title}</div>
                <div style="font-size: 0.8em; color: #666;">
                  ${displayDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}
                </div>
              </div>
            `;
            
            recentPostsList.appendChild(recentPostElement);
          });

          // Fetch comment counts for all posts
          for (const post of allPosts) {
            const commentsQuery = query(collection(db, `posts/${post.id}/comments`));
            const commentsSnapshot = await getDocs(commentsQuery);
            post.commentCount = commentsSnapshot.size;
          }

          // Initial sort by newest (default)
          sortPosts('newest');
          
          // Show initial sort indicator
          document.getElementById('activeSortIndicator').style.display = 'inline';
          
        } catch (error) {
          // Handle any errors during post loading
          console.error("Error fetching posts:", error);
          blogPostsContainer.innerHTML = "<p>Error loading posts.</p>";
        }
      })();
    });
  </script>

  <!-- Script for aligning About Me with Posts on mobile -->
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      // Function to align About Me with Posts
      function alignAboutMeWithPosts() {
        // Only apply on mobile screens
        if (window.innerWidth <= 768) {
          const postsSection = document.querySelector('.posts');
          const aboutMeSection = document.querySelector('.about-me');
          
          if (postsSection && aboutMeSection) {
            // Get the exact position of the posts section
            const postsRect = postsSection.getBoundingClientRect();
            const postsTop = postsRect.top + window.scrollY;
            
            // Set the About Me position to match
            aboutMeSection.style.top = postsTop + 'px';
          }
        }
      }
      
      // Run on page load
      alignAboutMeWithPosts();
      
      // Run on window resize
      window.addEventListener('resize', alignAboutMeWithPosts);
      
      // Run when content loads
      window.addEventListener('load', alignAboutMeWithPosts);
      
      // Run when scrolling starts (in case headers change size)
      window.addEventListener('scroll', function() {
        // Use requestAnimationFrame to limit execution
        if (!window.requestAnimationFrame) return alignAboutMeWithPosts();
        
        if (!this.running) {
          this.running = true;
          window.requestAnimationFrame(() => {
            alignAboutMeWithPosts();
            this.running = false;
          });
        }
      });
    });
  </script>

  <!-- Admin dropdown control script -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const adminDropdownBtn = document.getElementById('adminDropdownBtn');
      const whiteBox = document.querySelector('.black-box');
      const contactDropdownBtn = document.getElementById('contactDropdownBtn');
      const contactBox = document.querySelector('.contact-black-box');
      
      // Function to position white box under Admin Dashboard
      function positionWhiteBox() {
        if (adminDropdownBtn && whiteBox) {
          const rect = adminDropdownBtn.getBoundingClientRect();
          whiteBox.style.top = (rect.bottom) + 'px';
          whiteBox.style.left = rect.left + 'px';
          whiteBox.style.width = (rect.width < 180 ? 180 : rect.width) + 'px'; // Minimum width of 180px
        }
      }
      
      // Function to position contact box under Contact button
      function positionContactBox() {
        if (contactDropdownBtn && contactBox) {
          const rect = contactDropdownBtn.getBoundingClientRect();
          contactBox.style.top = (rect.bottom) + 'px';
          contactBox.style.left = rect.left + 'px';
          contactBox.style.width = (rect.width < 50 ? 50 : rect.width) + 'px !important'; // Minimum width of 50px with !important
        }
      }
      
      // Position boxes initially
      positionWhiteBox();
      positionContactBox();
      
      // Reposition on window resize
      window.addEventListener('resize', function() {
        positionWhiteBox();
        positionContactBox();
      });
      
      // Toggle admin dropdown when Admin Dashboard is clicked
      if (adminDropdownBtn && whiteBox) {
        adminDropdownBtn.addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          
          // Toggle white box display
          if (whiteBox.style.display === 'block') {
            whiteBox.style.display = 'none';
            this.classList.remove('active');
          } else {
            positionWhiteBox(); // Position before showing
            whiteBox.style.display = 'block';
            this.classList.add('active');
            
            // Hide contact dropdown if it's open
            if (contactBox) {
              contactBox.style.display = 'none';
              if (contactDropdownBtn) contactDropdownBtn.classList.remove('active');
            }
          }
        });
      }
      
      // Toggle contact dropdown when Contact is clicked
      if (contactDropdownBtn && contactBox) {
        contactDropdownBtn.addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          
          // Toggle contact box display
          if (contactBox.style.display === 'block') {
            contactBox.style.display = 'none';
            this.classList.remove('active');
          } else {
            positionContactBox(); // Position before showing
            contactBox.style.display = 'block';
            this.classList.add('active');
            
            // Hide admin dropdown if it's open
            if (whiteBox) {
              whiteBox.style.display = 'none';
              if (adminDropdownBtn) adminDropdownBtn.classList.remove('active');
            }
          }
        });
      }
      
      // Hide dropdowns when clicking outside
      document.addEventListener('click', function(e) {
        // Close admin dropdown
        if (whiteBox && whiteBox.style.display === 'block' && 
            adminDropdownBtn && !adminDropdownBtn.contains(e.target) && 
            !whiteBox.contains(e.target)) {
          whiteBox.style.display = 'none';
          adminDropdownBtn.classList.remove('active');
        }
        
        // Close contact dropdown
        if (contactBox && contactBox.style.display === 'block' && 
            contactDropdownBtn && !contactDropdownBtn.contains(e.target) && 
            !contactBox.contains(e.target)) {
          contactBox.style.display = 'none';
          contactDropdownBtn.classList.remove('active');
        }
      });
      
      // Hide dropdowns when scrolling
      window.addEventListener('scroll', function() {
        // Close admin dropdown
        if (whiteBox && whiteBox.style.display === 'block') {
          whiteBox.style.display = 'none';
          if (adminDropdownBtn) adminDropdownBtn.classList.remove('active');
        }
        
        // Close contact dropdown
        if (contactBox && contactBox.style.display === 'block') {
          contactBox.style.display = 'none';
          if (contactDropdownBtn) contactDropdownBtn.classList.remove('active');
        }
      });
    });
  </script>

  <!-- Edit Mode Script -->
  <script type="module">
    // Import Firebase modules
    import { auth, isAdminUser, db } from './firebase-config.js';
    import { onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.8.1/firebase-auth.js';
    import { doc, getDoc, setDoc, updateDoc } from 'https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js';

    document.addEventListener('DOMContentLoaded', function() {
      const editButton = document.getElementById('edit-mode-toggle');
      const editableElements = document.querySelectorAll('.editable');
      let editModeActive = false;
      
      // Store original content for each editable element
      const originalContent = {};
      editableElements.forEach((element, index) => {
        originalContent[index] = element.innerHTML;
      });

      // Show edit button for admin users only
      onAuthStateChanged(auth, async (user) => {
        if (user) {
          const isAdmin = await isAdminUser(user.uid);
          if (isAdmin && editButton) {
            editButton.style.display = 'flex';
          }
        }
      });

      // Toggle edit mode when pencil icon is clicked
      if (editButton) {
        editButton.addEventListener('click', function() {
          editModeActive = !editModeActive;
          
          // Toggle button appearance
          if (editModeActive) {
            // Enter edit mode
            editButton.classList.add('active');
            editButton.innerHTML = '<i class="fas fa-save"></i>';
            
            // Toggle contenteditable and visual style for all editable elements
            editableElements.forEach(element => {
              element.setAttribute('contenteditable', 'true');
              element.classList.add('edit-mode');
            });
          } else {
            // Exit edit mode and save changes
            editButton.classList.remove('active');
            editButton.innerHTML = '<i class="fas fa-pencil-alt"></i>';
            
            // Create an object to store the changes
            const updatedContent = {};
            let hasChanges = false;
            
            // Check which elements have been changed
            editableElements.forEach((element, index) => {
              const currentContent = element.innerHTML;
              if (currentContent !== originalContent[index]) {
                // Remove edit-mode class before getting path, to ensure
                // we can find the element again when page reloads
                element.classList.remove('edit-mode');
                
                // Store element information for identification
                const path = getElementPath(element);
                updatedContent[path] = {
                  content: currentContent,
                  elementType: element.tagName.toLowerCase()
                };
                hasChanges = true;
              }
              
              // Remove contenteditable and visual style
              element.removeAttribute('contenteditable');
              element.classList.remove('edit-mode');
            });
            
            // If changes were made, save them to Firebase
            if (hasChanges) {
              // Show saving indicator
              showSaveStatus('saving', 'Saving changes...');
              
              // Save to both Firebase and localStorage for redundancy
              saveContentToFirebase(updatedContent)
                .then(() => {
                  // Also save to localStorage as backup
                  try {
                    // Save to localStorage with timestamp
                    const localStorageData = {
                      content: updatedContent,
                      timestamp: new Date().toISOString(),
                      pageId: 'index_page_content'
                    };
                    localStorage.setItem('index_page_content', JSON.stringify(localStorageData));
                    console.log("✅ Also saved content to localStorage as backup");
                  } catch (localStorageError) {
                    console.warn("Could not save to localStorage:", localStorageError);
                  }
                  
                  showSaveStatus('success', 'Changes saved successfully!');
                  
                  // Update the original content with new values
                  editableElements.forEach((element, index) => {
                    originalContent[index] = element.innerHTML;
                  });
                })
                .catch(error => {
                  console.error('Error saving to Firebase:', error);
                  
                  // Try saving to localStorage as fallback
                  try {
                    const localStorageData = {
                      content: updatedContent,
                      timestamp: new Date().toISOString(),
                      pageId: 'index_page_content'
                    };
                    localStorage.setItem('index_page_content', JSON.stringify(localStorageData));
                    
                    showSaveStatus('success', 'Changes saved locally (offline mode)');
                    
                    // Update the original content with new values
                    editableElements.forEach((element, index) => {
                      originalContent[index] = element.innerHTML;
                    });
                  } catch (localStorageError) {
                    showSaveStatus('error', 'Failed to save changes');
                    console.error('Error saving to localStorage:', localStorageError);
                  }
                });
            }
          }
        });
      }
      
      // Function to get a unique path for an element
      function getElementPath(element) {
        const tagName = element.tagName.toLowerCase();
        
        // Get a cleaned version of the class list without edit-mode
        const classList = Array.from(element.classList)
          .filter(className => className !== 'edit-mode'); // Remove edit-mode class from path
        const classNames = classList.join('.');
        
        // Get parent information with more detail
        const parentElement = element.parentElement;
        const parentTagName = parentElement ? parentElement.tagName.toLowerCase() : '';
        
        // Get more specific parent class information
        let parentClassInfo = '';
        if (parentElement && parentElement.classList.length > 0) {
          parentClassInfo = '.' + Array.from(parentElement.classList).join('.');
        }
        
        // Get position index among siblings of same type
        let positionIndex = 0;
        if (parentElement) {
          const siblings = Array.from(parentElement.children).filter(el => el.tagName === element.tagName);
          positionIndex = siblings.indexOf(element) + 1;
        }
        
        // Include detailed position info in the path
        const positionInfo = parentElement ? `[${positionIndex}]` : '';
        
        // Include some content as a fingerprint (first 15 chars)
        const contentFingerprint = element.textContent.trim().substring(0, 15).replace(/\s+/g, '-');
        
        // Create a highly specific identifier for this element
        return `${parentTagName}${parentClassInfo}>${tagName}${positionInfo}.${classNames}:${contentFingerprint}`;
      }
      
      // Function to save content to Firebase
      async function saveContentToFirebase(updatedContent) {
        console.log("Attempting to save content to Firebase:", updatedContent);
        
        try {
          // Use page-specific document ID to prevent cross-page content sharing
          const pageDocId = "index_page_content";
          
          // Create/update content document in Firestore
          const contentRef = doc(db, "site_content", pageDocId);
          
          // Check if document exists
          const docSnap = await getDoc(contentRef);
          
          if (docSnap.exists()) {
            // Get current content
            const currentContent = docSnap.data().content || {};
            
            // Merge current content with updated content
            const mergedContent = { ...currentContent, ...updatedContent };
            console.log("Updating existing document with merged content:", mergedContent);
            
            // Update existing document
            await updateDoc(contentRef, {
              content: mergedContent,
              lastUpdated: new Date()
            });
            
            console.log("✅ Successfully updated document in Firebase");
            
            // Verify the update was successful by reading it back
            const verifySnap = await getDoc(contentRef);
            if (verifySnap.exists()) {
              console.log("✅ Verification successful - document contains:", verifySnap.data());
              return true;
            } else {
              console.error("❌ Verification failed - document not found after update");
              throw new Error("Document verification failed after update");
            }
          } else {
            console.log("Creating new document with content:", updatedContent);
            // Create new document
            await setDoc(contentRef, {
              content: updatedContent,
              lastUpdated: new Date()
            });
            
            console.log("✅ Successfully created new document in Firebase");
            
            // Verify the creation was successful
            const verifySnap = await getDoc(contentRef);
            if (verifySnap.exists()) {
              console.log("✅ Verification successful - new document contains:", verifySnap.data());
              return true;
            } else {
              console.error("❌ Verification failed - new document not found after creation");
              throw new Error("Document verification failed after creation");
            }
          }
        } catch (error) {
          console.error("❌ Error saving content to Firebase:", error);
          // Check for specific Firebase errors
          if (error.code) {
            console.error(`Firebase error code: ${error.code}`);
            console.error(`Firebase error message: ${error.message}`);
          }
          throw error;
        }
      }
      
      // Function to show save status
      function showSaveStatus(type, message) {
        const statusElement = document.getElementById('save-status');
        if (!statusElement) return;
        
        // Clear existing classes
        statusElement.className = '';
        
        // Add new classes
        statusElement.classList.add('show');
        statusElement.classList.add(type);
        
        // Set message
        statusElement.textContent = message;
        
        // Hide after a delay (except if it's "saving")
        if (type !== 'saving') {
          setTimeout(() => {
            statusElement.classList.remove('show');
          }, 3000);
        }
      }
    });
  </script>

  <!-- Load editable content script -->
  <script type="module">
    // Import Firebase modules immediately
    import { doc, getDoc, collection, getDocs } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js";
    import { db } from "./firebase-config.js";
    
    // Load saved content when the page loads
    document.addEventListener('DOMContentLoaded', async function() {
      // Function to specifically handle footer copyright content
      function handleFooterCopyright(savedContent) {
        let count = 0;
        
        // Check for footer copyright elements in the saved content
        for (const path in savedContent) {
          if (path.includes('footer>p') && path.includes('©')) {
            console.log('Found footer copyright element path, using direct approach');
            const footerParagraphs = document.querySelectorAll('footer p');
            
            if (footerParagraphs.length > 0) {
              // First try to find a paragraph with the copyright symbol
              let copyrightP = null;
              
              for (let i = 0; i < footerParagraphs.length; i++) {
                if (footerParagraphs[i].textContent.includes('©')) {
                  copyrightP = footerParagraphs[i];
                  break;
                }
              }
              
              // If found, update it
              if (copyrightP) {
                console.log('Found footer copyright element, updating');
                copyrightP.innerHTML = savedContent[path].content;
                count++;
              } else {
                // Otherwise update the first paragraph in the footer
                console.log('No copyright found in footer, updating first paragraph');
                footerParagraphs[0].innerHTML = savedContent[path].content;
                count++;
              }
            }
          }
        }
        
        return count;
      }
      
      try {
        // Use page-specific document ID to prevent cross-page content sharing
        const pageDocId = "index_page_content";
        
        // Try to load from Firebase first
        console.log("Loading saved content for index page...");
        let savedContent = null;
        let contentSource = 'firebase';
        
        try {
          // Test Firebase connection first
          console.log("Testing Firebase connection...");
          // Try to access a collection to verify connection
          const testCol = collection(db, "site_content");
          const testSnapshot = await getDocs(testCol);
          console.log(`✅ Firebase connection successful! Found ${testSnapshot.size} documents in collection.`);
          
          // Get the content document from Firestore
          const contentRef = doc(db, "site_content", pageDocId);
          const docSnap = await getDoc(contentRef);
          
          if (docSnap.exists() && docSnap.data().content) {
            console.log("✅ Found saved content in Firebase:", docSnap.data());
            savedContent = docSnap.data().content;
          } else {
            console.log("No content found in Firebase, checking localStorage...");
          }
        } catch (firebaseError) {
          console.error("❌ Firebase error:", firebaseError);
          console.log("Falling back to localStorage...");
        }
        
        // If no content from Firebase, try localStorage
        if (!savedContent) {
          try {
            const localData = localStorage.getItem(pageDocId);
            if (localData) {
              const parsedData = JSON.parse(localData);
              if (parsedData && parsedData.content) {
                console.log("✅ Found saved content in localStorage:", parsedData);
                savedContent = parsedData.content;
                contentSource = 'localStorage';
              }
            }
          } catch (localStorageError) {
            console.error("❌ Error reading from localStorage:", localStorageError);
          }
        }
        
        // If we have content from either source, apply it
        if (savedContent) {
          console.log(`Applying saved content from ${contentSource}`);
          
          // Count how many elements we'll update
          const elementsToUpdate = Object.keys(savedContent).length;
          console.log(`Found ${elementsToUpdate} saved elements to restore`);
          
          let updateCount = 0;
          
          // First, collect all editable elements for easy reference
          const allEditableElements = document.querySelectorAll('.editable');
          console.log(`Found ${allEditableElements.length} editable elements on page`);
          
          // A special function to handle footer copyright - one of the most common elements
          // This runs before the regular element processing
          updateCount += handleFooterCopyright(savedContent);
          
          // Apply saved content to matching elements
          Object.keys(savedContent).forEach(path => {
            // Skip footer copyright elements as they were handled specially
            if (path.includes('footer>p') && path.includes('©')) {
              console.log('Skipping footer copyright element - already handled');
              return;
            }
            
            try {
              console.log(`Processing saved element with path: ${path}`);
              
              // Format: parentTag.parentClasses>tag[position].classes:contentFingerprint
              
              // Extract the content fingerprint as it might help with identification
              const parts = path.split(':');
              const basePath = parts[0];
              const contentFingerprint = parts.length > 1 ? parts[1] : '';
              
              // Parse the element position if present
              let positionIndex = 0;
              let cleanBasePath = basePath;
              
              if (basePath.includes('[') && basePath.includes(']')) {
                const posMatch = basePath.match(/\[(\d+)\]/);
                if (posMatch && posMatch[1]) {
                  positionIndex = parseInt(posMatch[1]);
                  cleanBasePath = basePath.replace(/\[\d+\]/, '');
                }
              }
              
              // Split into parent and element parts
              const pathParts = cleanBasePath.split('>');
              if (pathParts.length < 2) {
                console.log(`Invalid path format, missing parent or element part: ${cleanBasePath}`);
                return; // Skip this element
              }
              
              const [parentInfo, elementInfo] = pathParts;
              
              // Extract parent tag and classes
              let parentTag = '', parentClasses = [];
              if (parentInfo.includes('.')) {
                const parentParts = parentInfo.split('.');
                parentTag = parentParts[0];
                parentClasses = parentParts.slice(1);
              } else {
                parentTag = parentInfo;
              }
              
              // Extract element tag and classes
              let tag = '', classes = [];
              if (elementInfo.includes('.')) {
                const elementParts = elementInfo.split('.');
                tag = elementParts[0];
                classes = elementParts.slice(1).filter(c => c !== 'edit-mode'); // Ensure edit-mode is filtered
              } else {
                tag = elementInfo;
              }
              
              // Ensure 'editable' is in the classes we're looking for
              if (!classes.includes('editable')) {
                classes.push('editable');
              }
              
              // Build selectors - first try specific selector
              const elementSelector = tag + (classes.length > 0 ? '.' + classes.join('.') : '');
              
              console.log(`Looking for elements matching: ${elementSelector} (position: ${positionIndex})`);
              
              // First find all matching elements with specific selector
              let elements = document.querySelectorAll(elementSelector);
              
              // If no elements found with specific selector, try a more general approach
              if (elements.length === 0) {
                console.log(`No elements found with specific selector, trying more general approach`);
                
                // Try just the tag.editable selector
                const simpleSelector = tag + '.editable';
                elements = document.querySelectorAll(simpleSelector);
                console.log(`Found ${elements.length} elements with simple selector ${simpleSelector}`);
                
                // Try to match by content fingerprint if available
                let matchFound = false;
                
                if (contentFingerprint) {
                  console.log(`Trying to match by fingerprint: "${contentFingerprint}"`);
                  elements.forEach(el => {
                    const elContent = el.textContent.trim().substring(0, 15).replace(/\s+/g, '-');
                    console.log(`Comparing fingerprints: "${elContent}" vs "${contentFingerprint}"`);
                    
                    // Try exact match first
                    if (elContent === contentFingerprint) {
                      console.log(`Found exact matching element with content fingerprint: ${contentFingerprint}`);
                      el.innerHTML = savedContent[path].content;
                      matchFound = true;
                      updateCount++;
                      return; // exit the forEach loop early
                    }
                    
                    // If no exact match, try partial match (element text contains fingerprint or fingerprint contains element text)
                    // This is especially useful for the copyright statement in the footer
                    if (!matchFound) {
                      const rawContent = el.textContent.trim();
                      const rawFingerprint = contentFingerprint.replace(/-/g, ' ');
                      if (rawContent.includes(rawFingerprint) || rawFingerprint.includes(rawContent)) {
                        console.log(`Found partial match with content fingerprint: "${contentFingerprint}" in "${rawContent.substring(0, 30)}..."`);
                        el.innerHTML = savedContent[path].content;
                        matchFound = true;
                        updateCount++;
                        return; // exit the forEach loop early
                      }
                    }
                  });
                }
              }
              
              if (elements.length > 0) {
                console.log(`Found ${elements.length} matching elements with selector`);
                
                // If we have position info, use it
                if (positionIndex > 0 && positionIndex <= elements.length) {
                  const specificElement = elements[positionIndex - 1];
                  
                  // Verify parent if possible
                  if (parentTag && specificElement.parentElement) {
                    const actualParent = specificElement.parentElement;
                    if (actualParent.tagName.toLowerCase() === parentTag.toLowerCase()) {
                      // Check parent classes if needed
                      let parentClassMatch = true;
                      if (parentClasses.length > 0) {
                        parentClassMatch = parentClasses.every(cls => 
                          actualParent.classList.contains(cls)
                        );
                      }
                      
                      console.log(`Parent tag match: ${actualParent.tagName.toLowerCase()} === ${parentTag.toLowerCase()}`);
                      console.log(`Parent class match: ${parentClassMatch}`);
                      
                      if (parentClassMatch) {
                        console.log(`Updating specific element at position ${positionIndex}`);
                        specificElement.innerHTML = savedContent[path].content;
                        updateCount++;
                      }
                    } else {
                      console.log(`Parent tag mismatch: ${actualParent.tagName.toLowerCase()} !== ${parentTag.toLowerCase()}`);
                    }
                  } else {
                    // Specific handling for footer elements
                    if (parentTag === 'footer' && specificElement.closest('footer')) {
                      console.log(`Found element within footer, updating`);
                      specificElement.innerHTML = savedContent[path].content;
                      updateCount++;
                    } else {
                      // No parent tag specified or element has no parent
                      console.log(`Updating specific element at position ${positionIndex} (no parent check)`);
                      specificElement.innerHTML = savedContent[path].content;
                      updateCount++;
                    }
                  }
                } else {
                  // Try to match by content fingerprint if available
                  let matchFound = false;
                  
                  if (contentFingerprint) {
                    console.log(`Trying to match by fingerprint: "${contentFingerprint}"`);
                    elements.forEach(el => {
                      const elContent = el.textContent.trim().substring(0, 15).replace(/\s+/g, '-');
                      console.log(`Comparing fingerprints: "${elContent}" vs "${contentFingerprint}"`);
                      
                      // Try exact match first
                      if (elContent === contentFingerprint) {
                        console.log(`Found exact matching element with content fingerprint: ${contentFingerprint}`);
                        el.innerHTML = savedContent[path].content;
                        matchFound = true;
                        updateCount++;
                        return; // exit the forEach loop early
                      }
                      
                      // If no exact match, try partial match (element text contains fingerprint or fingerprint contains element text)
                      // This is especially useful for the copyright statement in the footer
                      if (!matchFound) {
                        const rawContent = el.textContent.trim();
                        const rawFingerprint = contentFingerprint.replace(/-/g, ' ');
                        if (rawContent.includes(rawFingerprint) || rawFingerprint.includes(rawContent)) {
                          console.log(`Found partial match with content fingerprint: "${contentFingerprint}" in "${rawContent.substring(0, 30)}..."`);
                          el.innerHTML = savedContent[path].content;
                          matchFound = true;
                          updateCount++;
                          return; // exit the forEach loop early
                        }
                      }
                    });
                  }
                }
              } else {
                console.log(`No elements found matching selector, trying fallback approach`);
                
                // Fallback: Try matching by tag type and position among editable elements
                const tagEditables = Array.from(allEditableElements).filter(el => 
                  el.tagName.toLowerCase() === tag.toLowerCase()
                );
                
                if (tagEditables.length > 0) {
                  console.log(`Found ${tagEditables.length} ${tag} elements with .editable class`);
                  
                  // Use position index if available, otherwise use the first one
                  const targetIndex = (positionIndex > 0 && positionIndex <= tagEditables.length) 
                    ? positionIndex - 1 
                    : 0;
                  
                  console.log(`Updating ${tag} editable element at index ${targetIndex} as fallback`);
                  tagEditables[targetIndex].innerHTML = savedContent[path].content;
                  updateCount++;
                } else {
                  console.log(`No ${tag} elements with .editable class found`);
                }
              }
            } catch (error) {
              console.error(`Error processing path ${path}:`, error);
            }
          });
          
          console.log(`✅ Successfully restored ${updateCount} saved elements`);
          
          // Last resort fallback if no elements were updated
          if (updateCount === 0 && Object.keys(savedContent).length > 0) {
            console.log("⚠️ No elements updated through normal methods, trying last resort fallback");
            
            // Get all editable elements and footer paragraphs
            const editables = document.querySelectorAll('.editable');
            const footerP = document.querySelector('footer p');
            
            // Try to update elements based on saved content
            Object.values(savedContent).forEach(item => {
              const content = item.content;
              
              // Try to identify if this is footer content
              if (content.includes('©') && footerP) {
                console.log("Updating footer paragraph with copyright as fallback");
                footerP.innerHTML = content;
                updateCount++;
              } else if (editables.length > 0) {
                // For other content, try to match by element type and content similarity
                for (const el of editables) {
                  // Skip if we already updated footer content
                  if (el.closest('footer') && updateCount > 0) continue;
                  
                  // Check if element type matches
                  if (el.tagName.toLowerCase() === (item.elementType || 'p').toLowerCase()) {
                    console.log(`Updating ${el.tagName.toLowerCase()} element as last resort fallback`);
                    el.innerHTML = content;
                    updateCount++;
                    break;
                  }
                }
              }
            });
            
            console.log(`After fallback, restored ${updateCount} elements`);
          }
        } else {
          console.log("No saved content found in Firebase or localStorage");
        }
        
        // Show editable content regardless of whether updates happened
        // This ensures content is visible even if no saved version exists
        showContent();
      } catch (error) {
        console.error("Error loading saved content:", error);
        // Show content even if there was an error
        showContent();
      }
      
      // Helper function to show content and hide loader
      function showContent() {
        // Show all editable containers
        document.querySelectorAll('.editable-container').forEach(container => {
          container.classList.add('loaded');
        });
        
        // Hide the loading spinner
        const loader = document.getElementById('contentLoader');
        if (loader) {
          setTimeout(() => {
            loader.classList.add('hidden');
            // Remove from DOM after animation completes
            setTimeout(() => {
              loader.style.display = 'none';
            }, 500);
          }, 300);
        }
      }
    });
  </script>

</body>
</html>